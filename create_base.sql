/******************************************************************************/
/***          Generated by IBExpert 2012.02.21 07.04.2012 11:46:52          ***/
/******************************************************************************/

SET SQL DIALECT 3;

SET NAMES UTF8;

SET CLIENTLIB 'C:\Program Files (x86)\Firebird\Firebird_2_5\bin\fbclient.dll';


--CREATE DATABASE '10.2.101.6:E:\Db\BASE.FDB'
CREATE DATABASE 'base'
USER 'SYSDBA' PASSWORD 'masterkey'
PAGE_SIZE 8192
DEFAULT CHARACTER SET UTF8 COLLATION UNICODE_CI_AI;



/******************************************************************************/
/***                               Generators                               ***/
/*Начальное значение устанавливаем в 20 000 000 000,                        ***/
/*все последующие филиалы плюс       10 000 000 000  Standard Edition       ***/
/*все последующие филиалы плюс        1 000 000 000  Enterprise Edition     ***/
/******************************************************************************/

CREATE GENERATOR GEN_ALLOCATION_ID;
SET GENERATOR GEN_ALLOCATION_ID TO 20000000000;

CREATE GENERATOR GEN_DUALREC_ID;
SET GENERATOR GEN_DUALREC_ID TO 20000000000;

CREATE GENERATOR GEN_ELEMENT_DETAILS_ID;
SET GENERATOR GEN_ELEMENT_DETAILS_ID TO 20000000000;

CREATE GENERATOR GEN_ELEMENT_DEF_ID;
SET GENERATOR GEN_ELEMENT_DEF_ID TO 20000000000;

CREATE GENERATOR GEN_ELEMENT_DEF_VALUES_ID;
SET GENERATOR GEN_ELEMENT_DEF_VALUES_ID TO 20000000000;

CREATE GENERATOR GEN_ELEMENT_DEF2_Elements_ID;
SET GENERATOR GEN_ELEMENT_DEF2_Elements_ID TO 20000000000;

CREATE GENERATOR GEN_ELEMENTS_ID;
SET GENERATOR GEN_ELEMENTS_ID TO 20000000000;

CREATE GENERATOR GEN_OBJECTS_ID;
SET GENERATOR GEN_OBJECTS_ID TO 20000000000;

CREATE GENERATOR GEN_HEADERS_ID;
SET GENERATOR GEN_HEADERS_ID TO 20000000000;

CREATE GENERATOR GEN_HEADTYPES_ID;
SET GENERATOR GEN_HEADTYPES_ID TO 20000000000;

CREATE GENERATOR GEN_SLICES_ID;
SET GENERATOR GEN_SLICES_ID TO 20000000000;

CREATE GENERATOR GEN_PROPERTIES_ID;
SET GENERATOR GEN_PROPERTIES_ID TO 20000000000;

CREATE GENERATOR GEN_HEAD_SLICES_ID;
SET GENERATOR GEN_HEAD_SLICES_ID TO 20000000000;

CREATE GENERATOR GEN_HEADTYPES_DESTINATION_ID;
SET GENERATOR GEN_HEADTYPES_DESTINATION_ID TO 20000000000;

CREATE GENERATOR GEN_SPRAV_ID;
SET GENERATOR GEN_SPRAV_ID TO 20000000000;

CREATE GENERATOR GEN_PRICES_ID;
SET GENERATOR GEN_PRICES_ID TO 20000000000;

CREATE GENERATOR GEN_HEAD2HEAD_ID;
SET GENERATOR GEN_HEAD2HEAD_ID TO 20000000000;

CREATE GENERATOR GEN_SNAPSHOT_OBJECTS_ID;
SET GENERATOR GEN_SNAPSHOT_OBJECTS_ID TO 20000000000;

CREATE GENERATOR GEN_ED_IZM_ID;
SET GENERATOR GEN_ED_IZM_ID TO 20000000000;

CREATE GENERATOR GEN_CURRENCY_ID;
SET GENERATOR GEN_CURRENCY_ID TO 20000000000;

CREATE GENERATOR GEN_ALLOC_GPS_ID;
SET GENERATOR GEN_ALLOC_GPS_ID TO 20000000000;

CREATE SEQUENCE GEN_OBJECTS_CROSS_ID;
ALTER SEQUENCE GEN_OBJECTS_CROSS_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_HEADERS_CROSS_ID;
ALTER SEQUENCE GEN_HEADERS_CROSS_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_IMPORT_OBJECTS_ID;
ALTER SEQUENCE GEN_IMPORT_OBJECTS_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_IMPORT_CUSTOMERS_ID;
ALTER SEQUENCE GEN_IMPORT_CUSTOMERS_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_IMPORT_GPS_ID;
ALTER SEQUENCE GEN_IMPORT_GPS_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_CONTRACTS_ID;
ALTER SEQUENCE GEN_CONTRACTS_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_CUSTOMERS_ID;
ALTER SEQUENCE GEN_CUSTOMERS_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_CUSTOMERS_CROSS_ID;
ALTER SEQUENCE GEN_CUSTOMERS_CROSS_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_LIMIT_PAYMENTS_ID;
ALTER SEQUENCE GEN_LIMIT_PAYMENTS_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_TASK_TRANSPORTATION_ID;
ALTER SEQUENCE GEN_TASK_TRANSPORTATION_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_TASK_TRANSP_ELEMENTS_ID;
ALTER SEQUENCE GEN_TASK_TRANSP_ELEMENTS_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_VEHICLE_ID;
ALTER SEQUENCE GEN_VEHICLE_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_VEHICLE_ONLINE_ID;
ALTER SEQUENCE GEN_VEHICLE_ONLINE_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_YMAPS_ROUTE_ID;
ALTER SEQUENCE GEN_YMAPS_ROUTE_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_VEHICLE_CONDITION_ID;
ALTER SEQUENCE GEN_VEHICLE_CONDITION_ID RESTART WITH 20000000000;

CREATE SEQUENCE GEN_DICTIONARY_ID;
ALTER SEQUENCE GEN_DICTIONARY_ID RESTART WITH 20000000000;


/* 
--Import Entrada
EXECUTE block RETURNS (RESULT VARCHAR(30))
As
BEGIN
    execute procedure p_import_obj 20000000004;
    execute procedure p_import_cus;
    execute procedure p_cut_id;
    execute procedure p_import_gps;
    RESULT = 'OK';
  suspend;
END
 */
 
SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE PROCEDURE P_FILL_BASE
AS
BEGIN
  EXIT;
END^

SET TERM ; ^


/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/

Create Table MATRIX_LITTL
(
ID INTEGER NOT NULL,
j1 INTEGER, j2 INTEGER, j3 INTEGER, j4 INTEGER, j5 INTEGER, j6 INTEGER, j7 INTEGER,
j8 INTEGER, j9 INTEGER, j10 INTEGER, j11 INTEGER, j12 INTEGER, j13 INTEGER, j14 INTEGER,
j15 INTEGER, j16 INTEGER, j17 INTEGER, j18 INTEGER, j19 INTEGER, j20 INTEGER, j21 INTEGER,
j22 INTEGER, j23 INTEGER, j24 INTEGER, j25 INTEGER, j26 INTEGER, j27 INTEGER, j28 INTEGER,
j29 INTEGER, j30 INTEGER, j31 INTEGER, j32 INTEGER, j33 INTEGER, j34 INTEGER, j35 INTEGER,
j36 INTEGER, j37 INTEGER, j38 INTEGER, j39 INTEGER, j40 INTEGER, j41 INTEGER, j42 INTEGER,
j43 INTEGER, j44 INTEGER, j45 INTEGER, j46 INTEGER, j47 INTEGER, j48 INTEGER, j49 INTEGER,
j50 INTEGER, j51 INTEGER, j52 INTEGER, j53 INTEGER, j54 INTEGER, j55 INTEGER, j56 INTEGER, j57 INTEGER,
j58 INTEGER, j59 INTEGER, j60 INTEGER, j61 INTEGER, j62 INTEGER, j63 INTEGER, j64 INTEGER, j65 INTEGER,
j66 INTEGER, j67 INTEGER, j68 INTEGER, j69 INTEGER, j70 INTEGER, j71 INTEGER, j72 INTEGER, j73 INTEGER,
j74 INTEGER, j75 INTEGER, j76 INTEGER, j77 INTEGER, j78 INTEGER, j79 INTEGER
);
/*$$IBEC$$ 
Хранит список таблиц и их полей с типами по таблицам с последующей передачей
на клиента(для элементов форм и сеток данных), заполняется при помощи процедуры
 p_fill_dictionary(выборка из системнх таблиц - from RDB$FIELDS F, RDB$RELATION_FIELDS R
    where F.RDB$FIELD_NAME = R.RDB$FIELD_SOURCE and R.RDB$SYSTEM_FLAG = 0)
     при создании базы(включена в скрипт), далее в ручном режиме, можно
 выполнять после модификации метаданных в базе.
 Код типа данных для столбца FIELD_TYPE:
• 7 – SMALLINT;
• 8 – INTEGER;
• 10 – FLOAT;
• 12 – DATE;
• 13 – TIME;
• 14 – CHAR;
• 16 – BIGINT;
• 27 – DOUBLE PRECISION;
• 35 – TIMESTAMP;
• 37 – VARCHAR;
• 261 – BLOB.
 $$IBEC$$*/
CREATE TABLE DICTIONARY(
    ID       BIGINT NOT NULL,
    DB_TABLE VARCHAR(25),
    FIELD_NAME VARCHAR(25),
    FIELD_SOURCE VARCHAR(25),
    FIELD_POSITION INT,
    GRID_CAPTION VARCHAR(45),
    FIELD_TYPE VARCHAR(25),
    FIELD_LENGHT INT,
    GRID_LENGHT INT,
    CATEGORY VARCHAR(35),
    DEF_VALUE VARCHAR(75),
    READ_ONLY SMALLINT DEFAULT 0,
    VISIBLE SMALLINT DEFAULT 1,
    REQUIRED SMALLINT DEFAULT 0
);

CREATE TABLE PROPERTIES (
    ID       BIGINT NOT NULL,
    NAME     VARCHAR(175),
    VLV      VARCHAR(75),
    COMMENT  VARCHAR(275),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE ALLOCATION (
    ID      BIGINT NOT NULL,
    NAME    VARCHAR(175),
    PARENT  BIGINT,
    ID_CUS  BIGINT,
    S_ID    CHAR(11),
    ORD     INTEGER,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP    
);

CREATE TABLE ALLOC_GPS (
    ID          BIGINT NOT NULL,
    ID_ALLOC    BIGINT NOT NULL,
    SHIROTA      NUMERIC(16,13),
    DOLGOTA        NUMERIC(16,13),
    QUAD        INTEGER,
    IN_LINE     INTEGER,
    CIRCLE        INTEGER,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE ALLOC_TOPOLOG (
    ID          BIGINT NOT NULL,
    ID_ALLOC    BIGINT NOT NULL,
    ROW_NUM      VARCHAR(25),
    LVL_NUM        VARCHAR(25),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP        
);

CREATE TABLE CONTRACTS (
    ID          BIGINT NOT NULL,
    CODE        VARCHAR(25),
    NAME        VARCHAR(75),
    DATE_BEGIN  DATE,
    DATE_END    DATE,
    ID_PRICE    BIGINT,
    ID_CURR     BIGINT,
    ID_CUS        BIGINT,
    VID         SMALLINT,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP    
);

CREATE TABLE COLORS (
    ID          BIGINT,
    C_R        VARCHAR(25),
    C_E        VARCHAR(25),
    C_H        VARCHAR(25)
);

CREATE TABLE CURRENCY (
    ID       BIGINT NOT NULL,
    ID_CURR_FROM  BIGINT,
    ID_CURR_TO    BIGINT,
    DATA     DATE,
    BASE    INTEGER,
    RATE       NUMERIC(18,5),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE CUSTOMERS (
    ID                BIGINT NOT NULL,
    NAME              VARCHAR(75),
    NAME_FULL         VARCHAR(175),
    ID_CAT            BIGINT,
    S_ID              CHAR(11),
    U_F               VARCHAR(25),
    EGRPOU            VARCHAR(25),
    INN               VARCHAR(25),
    SVID_NDS          VARCHAR(25),
    WORK_TIME         VARCHAR(75),
    ID_ALLOC          BIGINT,
    DOSTAVKA_ADDRESS  VARCHAR(125),
    UR_ADDRESS        VARCHAR(125),
    FIZ_ADDRESS       VARCHAR(125),
    TEL_FAX           VARCHAR(75),
    EMAIL             VARCHAR(125),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE CUSTOMERS_CROSS (
    ID                BIGINT NOT NULL,
    ID_CUS              BIGINT,
    ID_CUS_CROSS      VARCHAR(45),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE DUALREC (
    ID           BIGINT NOT NULL,
    DATA         DATE,
    DT           INTEGER,
    KT           INTEGER,
    FLD_NAME     VARCHAR(75),
    ID_HEAD       BIGINT,
    ID_HEAD_TYPE  BIGINT,
    ID_SLICE     BIGINT,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


CREATE TABLE ED_IZM (
    ID        BIGINT NOT NULL,
    ID_OBJ    BIGINT,
    NAME       VARCHAR(25),
    WGT        NUMERIC(15,2), --вес weight 
    CPC          NUMERIC(15,2), --объем capacity
    KF          NUMERIC(15,2),
    VID       SMALLINT,
    EAN_13    VARCHAR(13),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE ELEMENT_DETAILS (
    ID        BIGINT NOT NULL,
    ID_OBJ    BIGINT,
    DATA      DATE,
    ID_ALLOC  BIGINT,
    AMOUNT    NUMERIC(18,5),
    PRICE     NUMERIC(18,5),
    ID_POS    BIGINT,
    ID_E      BIGINT,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE ELEMENTS (
    ID             BIGINT NOT NULL,
    ID_OBJ         BIGINT,
    AMOUNT         NUMERIC(18,5),
    ID_EDIZM         BIGINT,
    PRICE          NUMERIC(18,5),
    ID_HEAD        BIGINT,
    ID_PRICE         BIGINT,
    ID_CURR          BIGINT,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE ELEMENT_DEF (
    ID      BIGINT NOT NULL,
    NAME    VARCHAR(75),
    PARENT  BIGINT,
    ISBASE  SMALLINT
);

CREATE TABLE ELEMENT_DEF_VALUES (
    ID       BIGINT NOT NULL,
    ID_ED    BIGINT,
    ID_OBJ   BIGINT,
    VLV      NUMERIC(18,5),
    DATA     DATE
);

CREATE TABLE ELEMENT_DEF2_ELEMENTS (
    ID      BIGINT NOT NULL,
    ID_E    BIGINT,
    ID_EDV  BIGINT
);

CREATE TABLE OBJECTS (
    ID      BIGINT NOT NULL,
    NAME    VARCHAR(175),
    PARENT  BIGINT,
    ID_CAT  BIGINT,
    S_ID    CHAR(11),
    NDS     NUMERIC(18,5) DEFAULT 0.2,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP    
);

CREATE TABLE OBJECTS_CROSS (
    ID                BIGINT NOT NULL,
    ID_OBJ              BIGINT,
    ID_CUS              BIGINT,
    ID_OBJ_CROSS      VARCHAR(45),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE HEADERS (
    ID        BIGINT NOT NULL,
    ID_ALLOC_FROM  BIGINT,
    ID_ALLOC_TO    BIGINT,
    ID_TYPE          BIGINT,
    DATA             DATE,
    PARENT           BIGINT,
    S_ID          CHAR(11),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP        
);

CREATE TABLE HEADERS_CROSS (
    ID                BIGINT NOT NULL,
    ID_HEAD              BIGINT,
    ID_CUS            BIGINT,
    ID_HEAD_CROSS   VARCHAR(75),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE HEAD2HEAD (
    ID            BIGINT NOT NULL,
    ID_FROM_HEAD  BIGINT,
    ID_TO_HEAD    BIGINT,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE HEAD_SLICES (
    ID            BIGINT NOT NULL,
    ID_HEAD        BIGINT,
    ID_SLICE        BIGINT,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


CREATE TABLE HEADTYPES (
    ID        BIGINT NOT NULL,
    NAME  VARCHAR(175),
    SNAME  VARCHAR(9),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE HEADTYPES_DESTINATION (
    ID             BIGINT NOT NULL,
    ID_headquarters BIGINT NOT NULL,
    ID_FROM_TYPE    BIGINT,
    ID_TO_TYPE         BIGINT,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP        
);

CREATE TABLE IMPORT_OBJECTS (
    ID             BIGINT NOT NULL,
    ID_CROSS      VARCHAR(25),
    NAME           VARCHAR(75),
    ID_CH          VARCHAR(25),
    CHARACT        VARCHAR(75),
    EDIZM        VARCHAR(25),
    KF             NUMERIC(10,2),
    WGT            NUMERIC(10,2),
    CPC            NUMERIC(10,2),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IMPORT_CUSTOMERS (
    ID             BIGINT NOT NULL,
    ID_CROSS      VARCHAR(25),
    INN            VARCHAR(15),
    EGRPOU        VARCHAR(15),
    NAME           VARCHAR(75),
    NAME_FULL    VARCHAR(200),
    SVID_NDS    VARCHAR(15),
    MANAGER        VARCHAR(35),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IMPORT_GPS (
    ID             BIGINT NOT NULL,
    ID_CROSS      VARCHAR(25),
    NAME           VARCHAR(75),
    POINT        VARCHAR(75),
    SHIROTA        NUMERIC(16,13),
    DOLGOTA        NUMERIC(16,13),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IMPORT_REG (
    ID_CROSS      VARCHAR(25),
    NAME           VARCHAR(75),
    R            VARCHAR(5)
);

CREATE TABLE IMPORT_RAY (
    ID_CROSS      VARCHAR(25),
    NAME           VARCHAR(75),
    R            VARCHAR(45)
);
CREATE TABLE IMPORT_ORDERS (
    ID        VARCHAR(25),
    DATA      DATE,
    ID_CUS    VARCHAR(25),
    NAME_CUS  VARCHAR(75),
    POINT     VARCHAR(75),
    ID_OBJ    VARCHAR(25),
    NAME_OBJ  VARCHAR(75),
    ID_CH     VARCHAR(25),
    CHARACT   VARCHAR(75),
    EDIZM     VARCHAR(25),
    KF        NUMERIC(10,2),
    QTY       NUMERIC(10,2),
    QTY_M     NUMERIC(10,2),
    PRICE     NUMERIC(10,2),
    SUMMA     NUMERIC(10,2),
    CMT       VARCHAR(75),
    WGT       NUMERIC(10,2),
    SHIROTA   NUMERIC(16,13),
    DOLGOTA   NUMERIC(16,13)
);

CREATE TABLE LIMIT_PAYMENTS (
    ID         BIGINT NOT NULL,
    ID_CUS     BIGINT,
    ID_SLICE   BIGINT,
    ID_CAT       BIGINT,
    SUMMA      NUMERIC(18,5),
    COUNT_DAY  INTEGER,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE SLICES (
    ID    BIGINT NOT NULL,
    NAME  VARCHAR(175),
    NAME_LONG  VARCHAR(275),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE SPRAV (
    ID      BIGINT NOT NULL,
    NAME    VARCHAR(100) NOT NULL,
    PARENT  BIGINT,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE SNAPSHOT_OBJECTS (
    ID       BIGINT NOT NULL,
    ID_OBJ   BIGINT NOT NULL,
    AMOUNT   NUMERIC(18,5),
    PRICE_FOR_TYPE1  NUMERIC(18,5),
    PRICE_FOR_TYPE2  NUMERIC(18,5),
    PRICE_FOR_TYPE3  NUMERIC(18,5),
    PRICE_FOR_TYPE4  NUMERIC(18,5),
    PRICE_FOR_TYPE5  NUMERIC(18,5),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE PRICES (
    ID       BIGINT NOT NULL,
    ID_TYPE  BIGINT NOT NULL,
    ID_OBJ   BIGINT NOT NULL,
    DATA     DATE NOT NULL,
    PRICE    NUMERIC(18,5) NOT NULL,
    ID_CURR  BIGINT,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE TASK_TRANSPORTATION (
    ID        BIGINT NOT NULL,
    DATA      DATE,
    S_ID         CHAR(11),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP        
);

CREATE TABLE TASK_TRANSP_ELEMENTS (
    ID                BIGINT NOT NULL,
    ID_TASK              BIGINT NOT NULL,    
    ID_HEAD           BIGINT NOT NULL,
    ID_VH              BIGINT,
    XODKA              VARCHAR(15),
    XODKA_INT        INTEGER,
    SUMMA             NUMERIC(18,5),
    WGT               NUMERIC(18,5),
    MEST            NUMERIC(18,5),
    MEST_KEG        NUMERIC(18,5),
    DISTANCE        NUMERIC(18,5),
    TIME_ON            NUMERIC(10,2),
    SHIROTA           NUMERIC(16,13),
    DOLGOTA           NUMERIC(16,13),
    IN_LINE            INTEGER,
    QUAD            INTEGER,
    ID_TO             BIGINT,
    TO_NAME           VARCHAR(75),
    ID_ALLOC_TO     BIGINT,
    TO_ALLOC_NAME      VARCHAR(175),
    ID_REGION       BIGINT,
    ORD             INTEGER,
    D_SHIROTA      NUMERIC(7,4),
    D_DOLGOTA      NUMERIC(7,4),
    CIRCLE         INTEGER,
    POINT          VARCHAR(75),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


CREATE TABLE VEHICLE (
    ID            BIGINT NOT NULL,
    NUM              VARCHAR(25),
    LOAD_KG          NUMERIC(18,2),
    BODY_OBJEM    NUMERIC(18,2), --Объем кузова
    RASXOD_LIT     NUMERIC(18,2),
    WEIGHT        NUMERIC(18,2),
    SPEED          INTEGER,
    IsActive    SMALLINT DEFAULT 1,
    S_ID             CHAR(11),
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP        
);

CREATE TABLE VEHICLE_ONLINE (
    ID            BIGINT NOT NULL,
    ID_VEHICLE     BIGINT NOT NULL,
    DATA      DATE,
    ID_TASK     BIGINT,
    TIME_STAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE VEHICLE_CONDITION (
    ID            BIGINT NOT NULL,
    ID_TASK       BIGINT,
    ID_VH         BIGINT,
    QUAD          INTEGER,
    CIRCLE_START  INTEGER,
    CIRCLE_END    INTEGER
);


CREATE TABLE YMAPS_ROUTE (
    ID     BIGINT NOT NULL,
    ID_VH  BIGINT NOT NULL,
    ROUTE  INTEGER,
    TXT    VARCHAR(445)
);

Create Table TMP_MATRIX_LITTL_GRAF
(
    ID      BIGINT NOT NULL,
    START_P INTEGER, 
    END_P    INTEGER,
    ORD     SMALLINT
);    

Create Table TMP_MATRIX_LITTL_GRAF1
(
    ID              BIGINT NOT NULL,
    ID_TE             BIGINT,
    SHIROTA           NUMERIC(16,13),
    DOLGOTA           NUMERIC(16,13),
    ORD             SMALLINT
);    


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE DICTIONARY ADD CONSTRAINT PK_DICTIONARY PRIMARY KEY (ID);
ALTER TABLE TASK_TRANSPORTATION ADD CONSTRAINT PK_TASK_TRANSPORTATION PRIMARY KEY (ID);
ALTER TABLE VEHICLE ADD CONSTRAINT PK_VEHICLE PRIMARY KEY (ID);
ALTER TABLE VEHICLE_ONLINE ADD CONSTRAINT PK_VEHICLE_ONLINE PRIMARY KEY (ID);
ALTER TABLE VEHICLE_CONDITION ADD CONSTRAINT PK_VEHICLE_CONDITION PRIMARY KEY (ID);
ALTER TABLE ALLOCATION ADD CONSTRAINT PK_ALLOCATION PRIMARY KEY (ID);
ALTER TABLE CONTRACTS ADD CONSTRAINT PK_CONTRACTS PRIMARY KEY (ID);
ALTER TABLE DUALREC ADD CONSTRAINT PK_DUALREC PRIMARY KEY (ID);
ALTER TABLE ELEMENT_DETAILS ADD CONSTRAINT PK_ELEMENT_DETAILS PRIMARY KEY (ID);
ALTER TABLE ED_IZM ADD CONSTRAINT ED_IZM PRIMARY KEY (ID);
ALTER TABLE ELEMENTS ADD CONSTRAINT PK_ELEMENTS PRIMARY KEY (ID);
ALTER TABLE ELEMENT_DEF ADD CONSTRAINT PK_ELEMENT_DEF PRIMARY KEY (ID);
ALTER TABLE ELEMENT_DEF2_Elements ADD CONSTRAINT PK_ELEMENT_DEF2_Elements PRIMARY KEY (ID);
ALTER TABLE ELEMENT_DEF_VALUES ADD CONSTRAINT PK_ELEMENT_DEF_VALUES PRIMARY KEY (ID);
ALTER TABLE OBJECTS ADD CONSTRAINT PK_OBJECTS PRIMARY KEY (ID);
ALTER TABLE OBJECTS_CROSS ADD CONSTRAINT PK_OBJECTS_CROSS PRIMARY KEY (ID);
ALTER TABLE HEADERS ADD CONSTRAINT PK_HEADERS PRIMARY KEY (ID);
ALTER TABLE HEADTYPES ADD CONSTRAINT PK_HEADTYPES PRIMARY KEY (ID);
ALTER TABLE HEADTYPES_DESTINATION ADD CONSTRAINT PK_HEADTYPES_DESTINATION PRIMARY KEY (ID);
ALTER TABLE SLICES ADD CONSTRAINT PK_SLICES PRIMARY KEY (ID);
ALTER TABLE HEAD_SLICES ADD CONSTRAINT PK_HEAD_SLICES PRIMARY KEY (ID);
ALTER TABLE PROPERTIES ADD CONSTRAINT PK_PROPERTIES PRIMARY KEY (ID);
ALTER TABLE SPRAV ADD CONSTRAINT PK_SPRAV PRIMARY KEY (ID);
ALTER TABLE PRICES ADD CONSTRAINT PK_PRICES PRIMARY KEY (ID);
ALTER TABLE HEAD2HEAD ADD CONSTRAINT PK_HEAD2HEAD PRIMARY KEY (ID);
ALTER TABLE SNAPSHOT_OBJECTS ADD PRIMARY KEY (ID);
ALTER TABLE CURRENCY ADD CONSTRAINT PK_CURRENCY PRIMARY KEY (ID);
ALTER TABLE CUSTOMERS ADD CONSTRAINT PK_CUSTOMERS PRIMARY KEY (ID);
ALTER TABLE LIMIT_PAYMENTS ADD CONSTRAINT PK_LIMIT_PAYMENTS PRIMARY KEY (ID);
ALTER TABLE CUSTOMERS_CROSS ADD CONSTRAINT PK_CUS_CROSS PRIMARY KEY (ID);
ALTER TABLE HEADERS_CROSS ADD CONSTRAINT PK_HEADERS_CROSS PRIMARY KEY (ID);
ALTER TABLE ALLOC_GPS ADD CONSTRAINT PK_ALLOC_GPS PRIMARY KEY (ID);
ALTER TABLE TASK_TRANSP_ELEMENTS ADD CONSTRAINT PK_TASK_TRANSP_ELEM PRIMARY KEY (ID);
ALTER TABLE MATRIX_LITTL ADD CONSTRAINT PK_MATRIX_LITTL PRIMARY KEY (ID);
ALTER TABLE TMP_MATRIX_LITTL_GRAF ADD CONSTRAINT PK_TMP_MATRIX_GRAF PRIMARY KEY (ID);
ALTER TABLE TMP_MATRIX_LITTL_GRAF1 ADD CONSTRAINT PK_TMP_MATRIX_GRAF1 PRIMARY KEY (ID);

/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE INDEX DICTIONARY_FIELD_SOURCE ON DICTIONARY (FIELD_SOURCE);
CREATE UNIQUE INDEX DICTIONARY_DB_TABLE_FIELD_NAME ON DICTIONARY (FIELD_NAME, DB_TABLE);
CREATE INDEX DICTIONARY_FIELD_NAME ON DICTIONARY (FIELD_NAME);
CREATE INDEX ELEMENT_DEF2_EDV_IDX1 ON ELEMENT_DEF2_ELEMENTS (ID_EDV);
CREATE INDEX ELEMENT_DEF2_IDE_IDX1 ON ELEMENT_DEF2_ELEMENTS (ID_E);
CREATE INDEX ELEMENT_DETAILS_ALLOC_IDX ON ELEMENT_DETAILS (ID_ALLOC);
CREATE INDEX ELEMENT_DETAILS_DATA_IDX ON ELEMENT_DETAILS (DATA);
CREATE INDEX ELEMENT_DETAILS_IDE_IDX1 ON ELEMENT_DETAILS (ID_E);
CREATE INDEX ELEMENT_DETAILS_OBJ_POS_IDX ON ELEMENT_DETAILS (ID_OBJ, ID_POS);
CREATE INDEX ELEMENT_DEF_VALUES_OBJ_IDX1 ON ELEMENT_DEF_VALUES (ID_OBJ);
CREATE INDEX ELEMENT_DEF_VALUES__ED_IDX1 ON ELEMENT_DEF_VALUES (ID_ED);
CREATE INDEX ELEMENTS_IDOBJ_IDX ON ELEMENTS (ID_OBJ);
CREATE INDEX ELEMENTS_EDIZM_IDX ON ELEMENTS (ID_EDIZM);
CREATE INDEX ELEMENTS_ID_HEAD_IDX ON ELEMENTS (id_head);
CREATE INDEX ELEMENTS_CURR_IDX ON ELEMENTS (ID_CURR);
CREATE INDEX ELEMENTS_PRICE_IDX ON ELEMENTS (ID_PRICE);
CREATE INDEX ELEMENT_DEF_PARENT_IDX1 ON ELEMENT_DEF (PARENT);
CREATE INDEX DUALREC_IDSETTYPE_IDX1 ON DUALREC (id_head_TYPE);
CREATE INDEX DUALREC_DATA_IDX1 ON DUALREC (DATA);
CREATE UNIQUE INDEX ELEMENT_DEF_NAME_IDX1 ON ELEMENT_DEF (NAME);
CREATE INDEX HEADERS_SID_IDX ON HEADERS (S_ID);
CREATE INDEX HEADERS_DATA_IDX1 ON HEADERS (DATA);
CREATE INDEX HEADERS_TYPE_IDX1 ON HEADERS (ID_TYPE);
CREATE INDEX HEADERS_FROM_TO_IDX ON HEADERS (ID_ALLOC_FROM, ID_ALLOC_TO);
CREATE INDEX HEAD_SLICE_IDSET_IDX1 ON HEAD_SLICES (id_head);
CREATE INDEX HEAD_SLICE_IDSLICE_IDX1 ON HEAD_SLICES (ID_SLICE);
CREATE UNIQUE INDEX SLICES_NAMELONG_IDX1 ON SLICES (NAME_LONG);
CREATE UNIQUE INDEX SLICES_NAME_IDX ON SLICES (NAME);
CREATE UNIQUE INDEX PROPERTIES_NAME_IDX1 ON PROPERTIES (NAME);
CREATE INDEX PRICES_DATA_IDX ON PRICES (DATA);
CREATE INDEX PRICES_IDOBJ_IDX ON PRICES (ID_OBJ);
CREATE INDEX PRICES_IDTYPE_IDX ON PRICES (ID_TYPE);
CREATE INDEX PRICES_IDCURR_IDX ON PRICES (ID_CURR);
CREATE INDEX HEAD2HEAD_IDFROM_IDX ON HEAD2HEAD (ID_FROM_HEAD);
CREATE INDEX HEAD2HEAD_IDTO_IDX1 ON HEAD2HEAD (ID_TO_HEAD);
CREATE INDEX OBJECTS_NAME_IDX ON OBJECTS (NAME);
CREATE INDEX OBJECTS_NDS_IDX ON OBJECTS (NDS);
CREATE INDEX OBJECTS_SID_IDX ON OBJECTS (S_ID);
CREATE INDEX ALLOCATION_NAME_IDX ON ALLOCATION (NAME);
CREATE INDEX ALLOCATION_SID_IDX ON ALLOCATION (S_ID);
CREATE INDEX ALLOCATION_ID_CUS_IDX ON ALLOCATION (ID_CUS);
CREATE INDEX SNAPSHOT_OBJECTS_IDOBJ_IDX ON SNAPSHOT_OBJECTS (ID_OBJ);
CREATE INDEX CURRENCY_CURR_IDX ON CURRENCY (ID_CURR_FROM, ID_CURR_TO);
CREATE INDEX CURRENCY_DATA_IDX ON CURRENCY (DATA);
CREATE INDEX CONTRACTS_IDCUS_IDX ON CONTRACTS (ID_CUS);
CREATE INDEX CONTRACTS_IDCURR_IDX ON CONTRACTS (ID_CURR);
CREATE INDEX CONTRACTS_IDPRICE_IDX ON CONTRACTS (ID_PRICE);
CREATE INDEX CUSTOMERS_ADR_DOST_UR_FIZ_IDX ON CUSTOMERS (UR_ADDRESS, FIZ_ADDRESS);
CREATE INDEX CUSTOMERS_EGRPOU_IDX ON CUSTOMERS (EGRPOU);
CREATE INDEX CUSTOMERS_EMAIL_IDX ON CUSTOMERS (EMAIL);
CREATE INDEX CUSTOMERS_IDALLOC_IDX ON CUSTOMERS (ID_ALLOC);
CREATE INDEX CUSTOMERS_IDCAT_IDX ON CUSTOMERS (ID_CAT);
CREATE INDEX CUSTOMERS_INN_IDX ON CUSTOMERS (INN);
CREATE INDEX CUSTOMERS_NAME_FULL_IDX ON CUSTOMERS (NAME_FULL);
CREATE INDEX CUSTOMERS_NAME_IDX ON CUSTOMERS (NAME);
CREATE INDEX CUSTOMERS_SID_IDX ON CUSTOMERS (S_ID);
CREATE INDEX CUSTOMERS_SVIDNDS_IDX ON CUSTOMERS (SVID_NDS);
CREATE INDEX CUSTOMERS_TELFAX_IDX ON CUSTOMERS (TEL_FAX);
CREATE INDEX CUSTOMERS_UF_IDX ON CUSTOMERS (U_F);
CREATE INDEX LIMIT_PAYMENTS_CUS_IDX ON LIMIT_PAYMENTS (ID_CUS);
CREATE INDEX LIMIT_PAYMENTS_SLICE_IDX ON LIMIT_PAYMENTS (ID_SLICE);
CREATE INDEX ALLOC_GPS_SH_DL_IDX ON ALLOC_GPS (SHIROTA, DOLGOTA);
CREATE INDEX ALLOC_GPS_ALLOC_IDX ON ALLOC_GPS (ID_ALLOC);
CREATE INDEX ALLOC_GPS_QUAD_IDX ON ALLOC_GPS (QUAD);
CREATE INDEX ALLOC_GPS_IN_LINE_IDX ON ALLOC_GPS (IN_LINE);
CREATE INDEX ALLOC_GPS_CIRCLE_IDX ON ALLOC_GPS (CIRCLE);
CREATE INDEX TASK_TRANSP_ELEMENTS_CIRCLE_IDX ON TASK_TRANSP_ELEMENTS (CIRCLE);
CREATE INDEX TASK_TRANSP_ELEMENTS_HEAD_IDX ON TASK_TRANSP_ELEMENTS (ID_HEAD);
CREATE INDEX TASK_TRANSP_ELEMENTS_SH_DL_IDX ON TASK_TRANSP_ELEMENTS (SHIROTA, DOLGOTA);
CREATE INDEX TASK_TRANSP_ELEMENTS_TASK_IDX ON TASK_TRANSP_ELEMENTS (ID_TASK);
CREATE INDEX TASK_TRANSP_ELEMENTS_XODKA_IDX ON TASK_TRANSP_ELEMENTS (XODKA);
CREATE INDEX TASK_TRANSP_ELEMENTS_REGION_IDX ON TASK_TRANSP_ELEMENTS (ID_REGION);
CREATE INDEX TASK_TRANSP_ELEM_ORD_IDX ON TASK_TRANSP_ELEMENTS (ORD);
CREATE INDEX TASK_TRANSP_ELEM_XODKA_INT_IDX ON TASK_TRANSP_ELEMENTS (XODKA_INT);
CREATE INDEX TASK_TRANSP_ELEMENTS_QUAD_IDX ON TASK_TRANSP_ELEMENTS (QUAD);
CREATE INDEX OBJECTS_CROSS_ID_CUS_IDX ON OBJECTS_CROSS (ID_CUS);
CREATE INDEX OBJECTS_CROSS_ID_OBJ_IDX ON OBJECTS_CROSS (ID_OBJ);
CREATE INDEX OBJECTS_CROSS_OBJCROSS_IDX ON OBJECTS_CROSS (ID_OBJ_CROSS);
CREATE INDEX ED_IZM_OBJ_KF_IDX ON ED_IZM (ID_OBJ, KF);
CREATE UNIQUE INDEX ED_IZM_OBJ_NAME_IDX ON ED_IZM (ID_OBJ, NAME);
CREATE INDEX IMPORT_ORDERS_ID_IDX ON IMPORT_ORDERS (ID);
CREATE INDEX CUSTOMERS_CROSS_CUS_CROSS_IDX ON CUSTOMERS_CROSS (ID_CUS_CROSS);
CREATE INDEX CUSTOMERS_CROSS_ID_CUS_IDX ON CUSTOMERS_CROSS (ID_CUS);
CREATE INDEX HEADERS_CROSS_CROSS_IDX ON HEADERS_CROSS (ID_HEAD_CROSS);
CREATE INDEX HEADERS_CROSS_CUS_IDX ON HEADERS_CROSS (ID_CUS);
CREATE INDEX HEADERS_CROSS_HEAD_IDX ON HEADERS_CROSS (ID_HEAD);
CREATE INDEX VEHICLE_LOAD_KG_IDX ON VEHICLE (LOAD_KG);
CREATE INDEX VEHICLE_ONLINE_ID_TASK_IDX ON VEHICLE_ONLINE (ID_TASK);
CREATE INDEX VEHICLE_CONDITION_TASK_VH_IDX ON VEHICLE_CONDITION (ID_TASK, ID_VH);
CREATE INDEX ALLOCATION_PARENT_IDX ON ALLOCATION (PARENT);
CREATE INDEX ALLOCATION_ORD_IDX ON ALLOCATION (ORD);

/*******************  EXCEPTION ****************************/
CREATE EXCEPTION EXCEPTION_DEF_ISBASE 'Для деформатора уже есть базовый!';
CREATE EXCEPTION EXCEPTION_HEAD_GPS 'Не заданы гео. координаты для головной организации!';
CREATE EXCEPTION EXCEPTION_NOT_VH_ONLINE 'Нет машин на линии!';

/******************************************************************************/

/* View: V_VEHICLE_ONLINE */
CREATE OR ALTER VIEW V_VEHICLE_ONLINE(
    ID,
    ID_TASK,
    ID_VEHICLE,
    NUM,
    LOAD_KG,
    DATA,
    ISCHANGE)
AS
Select v.id, vo.id_task, ID_Vehicle, v.num ,v.load_kg, vo.data, 0 as isChange From
Vehicle_Online vo Left Join Vehicle v On vo.id_vehicle = v.id
;

/* View: V_VEHICLE */
CREATE OR ALTER VIEW V_VEHICLE(
    ID,
    NUM,
    LOAD_KG,
    BODY_OBJEM,
    RASXOD_LIT,
    WEIGHT,
    SPEED,
    S_ID,
    ISACTIVE)
AS
select id, num, load_kg,BODY_OBJEM, RASXOD_LIT, WEIGHT,
            SPEED, S_ID, ISACTIVE from Vehicle
;


/* View: V_PRICES */
CREATE OR ALTER VIEW V_PRICES(
    ID,
    NAME)
AS
Select id, name From Sprav as s
        Where s.parent = (Select cast(vlv as bigint) From Properties Where name = 'sprav_price')
;

/* View: V_CURRENCY */
/*$$IBEC$$ CREATE OR ALTER VIEW V_CURRENCY(
    ID,
    S_ID_CURR,
    NAME,
    KURS)
AS
Select s.id, s.id as s_id_curr, Cast(s.name as VarChar(5)) as name, c.rate as kurs From Sprav as s Left Join Currency c On s.id = c.id_curr
        Where s.parent = (Select cast(vlv as bigint) From Properties Where name = 'sprav_currency')
            and c.data = (Select Max(data) From Currency Where id_curr = s.id)
; $$IBEC$$*/

/* View: V_REMAINS */
CREATE OR ALTER VIEW V_REMAINS(
    ID_OBJ,
    AMOUNT)
AS
Select ED.ID_OBJ, Sum(ED.AMOUNT) as AMOUNT From ELEMENT_DETAILS ED
    Where ED.ID_ALLOC = (Select cast(vlv as bigint) as v From Properties Where name = 'headquarters')
    group by ED.ID_OBJ;

/* View: V_CONTRACTS */
CREATE OR ALTER VIEW V_CONTRACTS(
    ID,
    CODE,
    NAME,
    DATE_BEGIN,
    DATE_END,
    ID_PRICE,
    ID_CURR,
    ID_CUS,
    VID,
    CUR_NAME,
    PRICE_NAME)
AS
select c.ID, c.CODE, c.NAME, c.DATE_BEGIN, c.DATE_END,
        c.ID_PRICE, c.ID_CURR, c.ID_CUS, c.VID, cr.name as cur_name, p.name as price_name
 from Contracts c Left Join
                (Select id, cast(name as varchar(25)) as name From Sprav
                   Where parent = (Select cast(vlv as bigint) as id From Properties Where name = 'sprav_currency')) as cr
                             On c.id_curr = cr.id
                    Left Join
                (Select id, cast(name as varchar(25)) as name From Sprav
                   Where parent = (Select cast(vlv as bigint) as id From Properties Where name = 'sprav_price')) as p
                             On c.id_price = p.id
;

/* View: V_CLIENTS */
CREATE OR ALTER VIEW V_CLIENTS(
    ID,
    S_ID_CLI,
    NAME,
    NAME_FULL,
    ID_CAT,
    NAME_CAT,
    U_F,
    EGRPOU,
    INN,
    SVID_NDS,
    WORK_TIME,
    ID_ALLOC,
    DOSTAVKA_ADDRESS,
    UR_ADDRESS,
    FIZ_ADDRESS,
    TEL_FAX,
    EMAIL)
AS
Select c.id, c.s_id as s_id_cli, c.name, c.name_full, c.id_cat, s.name as name_cat,
    U_F, EGRPOU, INN, SVID_NDS, WORK_TIME, ID_ALLOC, DOSTAVKA_ADDRESS,
    UR_ADDRESS, FIZ_ADDRESS, TEL_FAX, EMAIL  From Customers c Left Join Sprav s On c.id_cat = s.id
;

/* View: V_OBJECTS */
CREATE OR ALTER VIEW V_OBJECTS(
    ID,
    S_ID_OBJ,
    NAME,
    PARENT,
    NAME_CAT,
    ID_CAT,
    NDS,
    AMOUNT,
    PRICE_FOR_TYPE1,
    PRICE_FOR_TYPE2,
    PRICE_FOR_TYPE3,
    PRICE_FOR_TYPE4,
    PRICE_FOR_TYPE5)
AS
Select
    o.id, trim(o.s_id) as s_id_obj, o.name, o.PARENT, s.name as name_cat, o.id_cat, o.nds,
    so.amount as amount,
        so.price_for_type1 as price_for_type1,
        so.price_for_type2 as price_for_type2,
        so.price_for_type3 as price_for_type3,
        so.price_for_type4 as price_for_type4,
        so.price_for_type5 as price_for_type5
    From Objects o
    Left Join Snapshot_Objects so On so.id_obj = o.id
  Left Join Sprav s On o.id_cat = s.id
;

/* View: V_ELEM_CLIENTS */
CREATE OR ALTER VIEW V_ELEM_CLIENTS(
    ID,
    S_ID_CLI,
    NAME,
    NAME_FULL,
    U_F,
    EGRPOU,
    INN,
    SVID_NDS,
    WORK_TIME,
    ID_ALLOC,
    DOSTAVKA_ADDRESS,
    UR_ADDRESS,
    FIZ_ADDRESS,
    TEL_FAX,
    EMAIL)
AS
select c.id, c.s_id_cli, c.name, c.name_full,
    U_F, EGRPOU, INN, SVID_NDS, WORK_TIME, ID_ALLOC, DOSTAVKA_ADDRESS,
    UR_ADDRESS, FIZ_ADDRESS, TEL_FAX, EMAIL From v_Clients c
;
  
/* View: V_ELEM_OBJECTS */
CREATE OR ALTER VIEW V_ELEM_OBJECTS(
    ID,
    S_ID_OBJ,
    NAME,
    ID_CAT,
    NDS)
AS
Select o.id, o.s_id_obj, o.name, o.id_cat, o.nds From v_Objects o
;


/* View: V_HEADERS */
CREATE OR ALTER VIEW V_HEADERS(
    ID,
    ID_TYPE,
    S_ID_HEAD,
    DATA,
    SUMMA,
    WGT,
    MEST,
    MEST_KEG,
    FROM_NAME,
    TO_NAME,
    FROM_ALLOC_NAME,
    TO_ALLOC_NAME,
    VID_DOC,
    ID_ALLOC_FROM,
    ID_ALLOC_TO,
    ID_FROM,
    ID_TO,
    POINT)
AS
Select h.id,h.id_type, h.s_id as s_id_head, h.data, e.summa, e.wgt, e.mest,
        e.mest_keg,cf.name as from_name, ct.name as to_name,
        a_f.name as from_alloc_name, a_t.name as to_alloc_name,
        ht.name as vid_doc, a_f.id as id_alloc_from, a_t.id as id_alloc_to,
        cf.id as id_from, ct.id as id_to, ct.fiz_address as point


From Headers h Inner Join
(SELECT e.id_head, Sum(COALESCE(e.amount,0.00)*COALESCE(e.price,0.00)) As summa,
        Sum((COALESCE(e.amount,0.00)/COALESCE(ed.kf,1.00))*COALESCE(ed.wgt,0.00)) As wgt,
        Sum((COALESCE(e.amount,0.00)/COALESCE(ed.kf,1.00))) as mest,
        Sum(CASE ed.kf
        WHEN 50 THEN e.amount/ed.kf
        WHEN 30 THEN e.amount/ed.kf
        ELSE 0.00
            END) as mest_keg
    From Elements e
        Inner Join Ed_Izm ed On e.id_edizm = ed.id
     Group by e.id_head) as e On h.id = e.id_head

        Inner Join HeadTypes ht On h.id_type = ht.id
        Inner Join Allocation a_f On h.id_alloc_from = a_f.id
        Inner Join Allocation a_t On h.id_alloc_to = a_t.id
        Inner Join Customers cf On cf.id = a_f.id_cus
        Inner Join Customers ct On ct.id = a_t.id_cus
;

/* View: V_ELEMENTS */
CREATE OR ALTER VIEW V_ELEMENTS(
    AMOUNT,
    ED_NAME,
    KF,
    MEST,
    PRICE,
    SUMMA,
    S_ID_HEAD,
    DATA,
    VID_DOC,
    FROM_NAME,
    TO_NAME,
    ID,
    ID_OBJ,
    S_ID_OBJ,
    NAME,
    ID_ALLOC_FROM,
    ID_ALLOC_TO,
    ID_HEAD,
    ID_EDIZM,
    ID_PRICE,
    ID_CURR,
    ISCHANGE)
AS
Select e.amount, ei.name as ed_name, ei.kf, e.amount/ei.kf as mest, e.price, Round(e.price*e.amount,2) as summa,
    h.s_id as s_id_head, h.data, ht.name as vid_doc,
       a_f.name as from_name, a_t.name as to_name,
        e.id, e.id_obj, o.s_id as s_id_obj, o.name,
       h.id_alloc_from, h.id_alloc_to,e.id_head, e.id_edizm, e.id_price, e.id_curr, 0 as IsChange
 From Elements e
    Left Outer Join Objects o On e.id_obj = o.id
    Left Outer Join Headers h On e.id_head = h.id
    Left Outer Join Allocation a_f On h.id_alloc_from = a_f.id
    Left Outer Join Allocation a_t On h.id_alloc_to = a_t.id
    Left Outer Join HeadTypes ht On h.id_type = ht.id
    Left Outer Join ED_IZM ei On e.id_edizm = ei.id
 LEFT OUTER JOIN (Select ed.id_e,AVG(ed.price) as price
                                     From Element_Details AS ed Where ed.amount < 0
                                     Group by ed.id_e) as edd ON e.id = edd.id_e
Order by e.id
;

/*==============================================================*/
/* View: v_Using                                                */
/*==============================================================
create view v_Using as
SELECT u.dt,u.kt,e.summa_from_price FROM v_Elements e Left Outer Join Sets s On e.id_head=s.id  
                        Inner Join SetTypes st On s.id_type = st.id 
                                Inner Join DUALREC u On u.id_head_type = st.id Where u.fld_name='e.summa' 
                                UNION SELECT u.dt,u.kt,e.summa*e.nds FROM v_Elements e Left Outer Join Sets s On e.id_head=s.id  
                        Inner Join SetTypes st On s.id_type = st.id 
                                Inner Join DUALREC u On u.id_head_type = st.id Where u.fld_name='e.summa*e.nds';*/
/*==============================================================*/
/* View: v_Using_Oborotka                                       */
/*==============================================================
create view v_Using_Oborotka as
SELECT     acc.acc, dt.dt, dt.summa_dt, kt.kt, kt.summa_kt,
COALESCE(kt.summa_kt, 0) - COALESCE(dt.summa_dt, 0) AS saldo
FROM         (SELECT DISTINCT dt AS acc
                       FROM         DUALREC
                       UNION
                       SELECT DISTINCT kt AS acc
                       FROM         DUALREC) AS acc LEFT OUTER JOIN
                          (SELECT     dt, SUM(summa) AS summa_dt
                            FROM          v_Using AS u
                            GROUP BY dt) AS dt ON acc.acc = dt.dt LEFT OUTER JOIN
                          (SELECT     kt, SUM(summa) AS summa_kt
                            FROM          v_Using AS u
                            GROUP BY kt) AS kt ON acc.acc = kt.kt;*/

/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

/*$$IBEC$$ 
ПОЛУЧЕНИЕ СПИСКА ПОЛЕЙ И ИХ ТИПОВ ПО ТАБЛИЦАМ ДЛЯ ПОСЛЕДУЮЩЕЙ ПЕРЕДАЧИ
НА КЛИЕНТА(для элементов форм и сеток данных) ЧЕРЕЗ ТАБЛИЦУ DICTIONARY
$$IBEC$$*/
SET TERM ^ ;
CREATE OR ALTER PROCEDURE p_fill_dictionary
AS
--    DECLARE VARIABLE ID_P BIGINT;
    DECLARE VARIABLE DB_TABLE VARCHAR(25);
    DECLARE VARIABLE FIELD_NAME VARCHAR(25);
    DECLARE VARIABLE FIELD_SOURCE VARCHAR(25);
    DECLARE VARIABLE FIELD_POSITION INT;
    DECLARE VARIABLE FIELD_TYPE VARCHAR(25);
    DECLARE VARIABLE FIELD_LENGHT INT ;
    DECLARE VARIABLE NPRICE VARCHAR(25);
    DECLARE VARIABLE NPRICE_IN_SPRAV VARCHAR(25);
    /* DECLARE VARIABLE GRID_LENGHT INT ;
    DECLARE VARIABLE DEF_VALUE VARCHAR(75);
    DECLARE VARIABLE READ_ONLY SMALLINT;
    DECLARE VARIABLE VISIBLE SMALLINT;
    DECLARE VARIABLE REQUIRED SMALLINT;*/  
begin    
    
    FOR Select R.RDB$RELATION_NAME as DB_TABLE, R.RDB$FIELD_NAME as FIELD_NAME, R.RDB$FIELD_POSITION as FIELD_POSITION,
    F.RDB$FIELD_LENGTH as FIELD_LENGTH, F.RDB$FIELD_TYPE as FIELD_TYPE, R.RDB$FIELD_SOURCE as FIELD_SOURCE
    from RDB$FIELDS F, RDB$RELATION_FIELDS R
    where F.RDB$FIELD_NAME = R.RDB$FIELD_SOURCE and R.RDB$SYSTEM_FLAG = 0
        and Not Exists(Select id From Dictionary Where Field_Source = R.RDB$FIELD_SOURCE)
    order by R.RDB$RELATION_NAME, R.RDB$FIELD_POSITION 
    INTO :DB_TABLE, :FIELD_NAME, :FIELD_POSITION, :FIELD_LENGHT, :FIELD_TYPE, :FIELD_SOURCE DO
        begin
         Insert Into DICTIONARY (ID, DB_TABLE, FIELD_NAME, FIELD_POSITION, FIELD_LENGHT, GRID_LENGHT, FIELD_TYPE, FIELD_SOURCE)
          Values (GEN_ID(GEN_DICTIONARY_ID, 1), :DB_TABLE, :FIELD_NAME, :FIELD_POSITION, :FIELD_LENGHT, :FIELD_LENGHT*2, :FIELD_TYPE, :FIELD_SOURCE);
        end
    update DICTIONARY Set GRID_CAPTION = 'Код' where FIELD_NAME = 'S_ID_OBJ' and GRID_CAPTION is null;
    update DICTIONARY Set GRID_CAPTION = 'Наименование' where FIELD_NAME = 'NAME' and GRID_CAPTION is null;
    update DICTIONARY Set GRID_CAPTION = 'Цена' where FIELD_NAME = 'PRICE' and GRID_CAPTION is null;
    update DICTIONARY Set GRID_CAPTION = 'Кол-во' where FIELD_NAME = 'AMOUNT' and GRID_CAPTION is null;
    update DICTIONARY Set GRID_CAPTION = 'Номер' where FIELD_NAME = 'S_ID_HEAD' and GRID_CAPTION is null;
    update DICTIONARY Set GRID_CAPTION = 'Дата' where FIELD_NAME = 'DATA' and GRID_CAPTION is null;
    update DICTIONARY Set GRID_CAPTION = 'От кого' where FIELD_NAME = 'FROM_NAME' and GRID_CAPTION is null;
    update DICTIONARY Set GRID_CAPTION = 'Кому' where FIELD_NAME = 'TO_NAME' and GRID_CAPTION is null;
    /*$$IBEC$$
        Для полей 'P1_PRICE' , 'P2_PRICE', 'Pn_PRICE' выбираем названия их типов -
            таблица Properties названия типов цен из Sprav $$IBEC$$*/
    FOR Select name From Properties Where name LIKE 'PRICE_FOR_TYPE%' INTO :NPRICE do
        begin
            Select cast(sp.name as varchar(25)) as name From Properties pp Inner Join Sprav sp
               On cast(pp.vlv as BIGINT) = sp.id
               Where pp.name = :NPRICE  INTO :NPRICE_IN_SPRAV;
            Update DICTIONARY Set GRID_CAPTION = :NPRICE_IN_SPRAV where FIELD_NAME = :NPRICE;
        end


  /*$$IBEC$$   (('s_id_obj','№Объекта'),('name','Название'),('price','Цена'),('amount','Кол-во'),
      ('s_id_head','№Документа'), ('data','Дата'), ('vid_doc','Документ'),
      ('from_name','От кого'), ('to_name','Кому'), ('name_cat','Категория'),
      ('P1_PRICE','Цена_1'), ('P2_PRICE','Цена_2'), ('P3_PRICE','Цена_3'),
      ('P4_PRICE','Цена_4'), ('P5_PRICE','Цена_5'),
      ('Summa','Сумма'), ('s_id_cli','Код'), ('s_id_curr','Код'),
      ('kurs','курс'), ('CUR_NAME','Валюта'), ('PRICE_NAME','Тип цен'), ('code','Код'), ('DATE_BEGIN','дата начала'),
      ('DATE_END','дата завершения'),
      ('NUM','Номер машины'), ('LOAD_KG','Грузоподъемность'), ('XODKA','Ходка'),
      ('WGT','Вес груза'), ('MEST','Мест'), ('MEST_KEG','Кеги'),
      ('DISTANCE','Ощий путь'), ('TIME_ON','Время'), ('POINT','Тчк.'),
      ('REGION','Регион'),('ORD','Порядок'),('ID_CROSS','Кросс_код'),('ID_HEAD','№_док'),
      ('ISACTIVE', 'Активна')); $$IBEC$$*/

end^

SET TERM ; ^


SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_auto_select_vh (
    id_task BIGINT NOT NULL)
AS
DECLARE VARIABLE id_vh BIGINT;
DECLARE VARIABLE load_kg NUMERIC(18,5);
DECLARE VARIABLE q1_wgt NUMERIC(10,2);
DECLARE VARIABLE q2_wgt NUMERIC(10,2);
DECLARE VARIABLE q3_wgt NUMERIC(10,2);
DECLARE VARIABLE q4_wgt NUMERIC(10,2);
DECLARE VARIABLE q1_point NUMERIC(10,2);
DECLARE VARIABLE q2_point NUMERIC(10,2);
DECLARE VARIABLE q3_point NUMERIC(10,2);
DECLARE VARIABLE q4_point NUMERIC(10,2);

DECLARE VARIABLE over_load_vh INTEGER;
DECLARE VARIABLE limit_point_vh INTEGER;
DECLARE VARIABLE vsego_wgt   NUMERIC(18,5);
DECLARE VARIABLE vsego_point NUMERIC(18,5);

begin
Select cast(vlv as INTEGER) as v From Properties Where name = 'over_load_vh' ROWS 1 INTO :over_load_vh;
Select cast(vlv as INTEGER) as v From Properties Where name = 'limit_point_vh' ROWS 1 INTO :limit_point_vh;
Select Sum(te.wgt) as wgt From Task_Transp_Elements te Where quad = 1 and id_task = :id_task INTO :Q1_Wgt;
Select Sum(te.wgt) as wgt From Task_Transp_Elements te Where quad = 2 and id_task = :id_task INTO :Q2_Wgt;
Select Sum(te.wgt) as wgt From Task_Transp_Elements te Where quad = 3 and id_task = :id_task INTO :Q3_Wgt;
Select Sum(te.wgt) as wgt From Task_Transp_Elements te Where quad = 4 and id_task = :id_task INTO :Q4_Wgt;

Select Count(te.id) as cnt From Task_Transp_Elements te Where quad = 1 and id_task = :id_task INTO :Q1_point;
Select Count(te.id) as cnt From Task_Transp_Elements te Where quad = 2 and id_task = :id_task INTO :Q2_point;
Select Count(te.id) as cnt From Task_Transp_Elements te Where quad = 3 and id_task = :id_task INTO :Q3_point;
Select Count(te.id) as cnt From Task_Transp_Elements te Where quad = 4 and id_task = :id_task INTO :Q4_point;

Select Sum(te.wgt) as wgt From Task_Transp_Elements te Where id_task = :id_task INTO :vsego_wgt;
Select Count(te.id) as cnt From Task_Transp_Elements te Where id_task = :id_task INTO :vsego_point;
    Delete From VEHICLE_ONLINE Where id_task = :id_task;
    Delete From VEHICLE_CONDITION Where id_task = :id_task;

    FOR Select v.id,v.load_kg From VEHICLE v WHERE IsActive = 1 and
           Not Exists (Select vo.* From VEHICLE_ONLINE vo Where vo.ID_VEHICLE = v.id and vo.id_task = :id_task) INTO :id_vh, :load_kg DO
        begin
         if ((:load_kg+:over_load_vh>=:Q1_Wgt) and (:Q1_point<=:limit_point_vh)) then
          begin
             Insert Into VEHICLE_ONLINE (ID, ID_VEHICLE, ID_TASK)
                                     Values (GEN_ID(GEN_VEHICLE_ONLINE_ID, 1), :ID_VH, :ID_TASK);
             Insert Into VEHICLE_CONDITION (ID, ID_VH, ID_TASK, QUAD, circle_start, circle_end)
                                 Values (GEN_ID(GEN_VEHICLE_CONDITION_ID, 1), :ID_VH, :ID_TASK, 1, 0, 1000);
          end
         else if (((:load_kg+:over_load_vh>=:Q2_Wgt) and (:Q2_point<=:limit_point_vh))) then
          begin
             Insert Into VEHICLE_ONLINE (ID, ID_VEHICLE, ID_TASK)
                                     Values (GEN_ID(GEN_VEHICLE_ONLINE_ID, 1), :ID_VH, :ID_TASK);
             Insert Into VEHICLE_CONDITION (ID, ID_VH, ID_TASK, QUAD, circle_start, circle_end)
                                 Values (GEN_ID(GEN_VEHICLE_CONDITION_ID, 1), :ID_VH, :ID_TASK, 2, 0, 1000);
          end
         else if (((:load_kg+:over_load_vh>=:Q3_Wgt) and (:Q3_point<=:limit_point_vh))) then
          begin
             Insert Into VEHICLE_ONLINE (ID, ID_VEHICLE, ID_TASK)
                                     Values (GEN_ID(GEN_VEHICLE_ONLINE_ID, 1), :ID_VH, :ID_TASK);
             Insert Into VEHICLE_CONDITION (ID, ID_VH, ID_TASK, QUAD, circle_start, circle_end)
                                 Values (GEN_ID(GEN_VEHICLE_CONDITION_ID, 1), :ID_VH, :ID_TASK, 3, 0, 1000);
          end
         else if (((:load_kg+:over_load_vh>=:Q4_Wgt) and (:Q4_point<=:limit_point_vh))) then
          begin
             Insert Into VEHICLE_ONLINE (ID, ID_VEHICLE, ID_TASK)
                                     Values (GEN_ID(GEN_VEHICLE_ONLINE_ID, 1), :ID_VH, :ID_TASK);
             Insert Into VEHICLE_CONDITION (ID, ID_VH, ID_TASK, QUAD, circle_start, circle_end)
                                 Values (GEN_ID(GEN_VEHICLE_CONDITION_ID, 1), :ID_VH, :ID_TASK, 4, 0, 1000);
          end

        end
end^

SET TERM ; ^



SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_msh_geo_1x1 (
--приводит  широту и долготу к виду для расположения в квадрате 1Х1 
--из 48,09143    37,945739    получим     0,394135    0,991
    id_task BIGINT,
    id_vh BIGINT,
    xodka VARCHAR(10))
RETURNS (
    old_shirota NUMERIC(16,13),
    old_dolgota NUMERIC(16,13),
    shirota NUMERIC(16,13),
    dolgota NUMERIC(16,13),
    minshirota NUMERIC(16,13),
    mindolgota NUMERIC(16,13),
    id_te BIGINT)
AS
DECLARE VARIABLE  mnoj_shirota NUMERIC(8,3);
DECLARE VARIABLE  min_shirota  NUMERIC(16,13);
DECLARE VARIABLE  mnoj_dolgota NUMERIC(8,3);
DECLARE VARIABLE  min_dolgota  NUMERIC(16,13);
DECLARE VARIABLE  head_shirota NUMERIC(16,13);
DECLARE VARIABLE  head_dolgota NUMERIC(16,13);
DECLARE VARIABLE  headquarters BIGINT;
begin
   Select cast(vlv as bigint) as v From Properties Where name = 'headquarters' ROWS 1 INTO :headquarters;
   head_shirota = null; head_dolgota = null;
   Select ag.shirota, ag.dolgota From Alloc_Gps ag INNER JOIN Allocation a On a.id = ag.id_alloc
    Where a.id_cus = :headquarters  INTO :head_shirota, :head_dolgota;
if ((:head_shirota is null) or (:head_dolgota is null)) then
 begin
  EXCEPTION EXCEPTION_HEAD_GPS;
 end

Select Trunc(1/(Max(te.shirota) - Min(te.shirota)),6) From Task_Transp_Elements te
    Where te.id_task = :id_task and te.id_vh = :id_vh and te.xodka = :xodka
      INTO :mnoj_shirota;
Select Min(te.shirota) From Task_Transp_Elements te
    Where te.id_task = :id_task and te.id_vh = :id_vh and te.xodka = :xodka
      INTO :min_shirota;
Select Trunc(1/(Max(te.dolgota) - Min(te.dolgota)),6) From Task_Transp_Elements te
    Where te.id_task = :id_task and te.id_vh = :id_vh and te.xodka = :xodka
      INTO :mnoj_dolgota;
Select Min(te.dolgota) From Task_Transp_Elements te
    Where te.id_task = :id_task and te.id_vh = :id_vh and te.xodka = :xodka
      INTO :min_dolgota;

    For Select Trunc((:head_shirota - :min_shirota)*:mnoj_shirota,6),
               Trunc((:head_dolgota - :min_dolgota)*:mnoj_dolgota,6),
               :head_shirota,:head_dolgota
     FROM RDB$DATABASE Into :shirota, :dolgota,:old_shirota, :old_dolgota
      DO
      begin
        Suspend;
      end
    For Select te.id as id_te,
    IIF(Trunc((te.shirota - :min_shirota)*:mnoj_shirota,6) >=0.999,0.991,Trunc((te.shirota - :min_shirota)*:mnoj_shirota,6)) as shirota,
    IIF(Trunc((te.dolgota - :min_dolgota)*:mnoj_dolgota,6) >=0.999,0.991,Trunc((te.dolgota - :min_dolgota)*:mnoj_dolgota,6)) as dolgota,
          :min_shirota, :min_dolgota, te.shirota as old_shirota, te.dolgota as old_dolgota
          From Task_Transp_Elements te
        Where te.id_task = :id_task and te.id_vh = :id_vh and te.xodka = :xodka and te.id_head <> -1
     Into :id_te, :shirota, :dolgota, :minshirota, :mindolgota,
         :old_shirota, :old_dolgota
      DO
      begin
        Suspend;
      end

end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_point_in_line(x1 NUMERIC(6,4), y1 NUMERIC(6,4),
        x2 NUMERIC(6,4), y2 NUMERIC(6,4), x NUMERIC(6,4), y NUMERIC(6,4))
Returns(yes integer)
AS
 --принадлежит ли точка(x,y) через уравнение прямой проходящей через две точки(x1,y1)-(x2,y2)
 -- этой прямой
declare variable k DOUBLE PRECISION;
declare variable b DOUBLE PRECISION;

begin
    SELECT ROUND((:y2-:y1)/(:x2-:x1), 4) FROM RDB$DATABASE INTO :k;
    SELECT ROUND(:y1-:k*:x1, 4) FROM RDB$DATABASE INTO :b;
--0.0005 Толщина прямой
    if ((:y <= (:k*:x + :b) + 0.0005) and (:y >= (:k*:x + :b) - 0.0005)) then -- Точка принадлежит прямой
     begin
       yes = 1;
     end
    else    yes = 0;
SELECT :yes FROM RDB$DATABASE
    INTO :yes;

suspend;
end^

SET TERM ; ^


SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_get_xy_quad(n_quad int)
RETURNS (
     a1 NUMERIC(6,4), a2 NUMERIC(6,4), a3 NUMERIC(6,4), a4 NUMERIC(6,4))
AS
 --Берем координаты квадратов по диагонали
declare variable max_shirota  DOUBLE PRECISION;
declare variable min_shirota  DOUBLE PRECISION;
declare variable max_dolgota  DOUBLE PRECISION;
declare variable min_dolgota  DOUBLE PRECISION;
declare variable head_shirota DOUBLE PRECISION;
declare variable head_dolgota DOUBLE PRECISION;
declare variable headquarters BIGINT;
declare variable h1 DOUBLE PRECISION;
declare variable h2 DOUBLE PRECISION;
declare variable d1 DOUBLE PRECISION;
declare variable d2 DOUBLE PRECISION;
begin
   Select cast(vlv as bigint) as v From Properties Where name = 'headquarters' ROWS 1 INTO :headquarters;
   Select ag.shirota, ag.dolgota From Alloc_Gps ag INNER JOIN Allocation a On a.id = ag.id_alloc
    Where a.id_cus = :headquarters  INTO :head_shirota, :head_dolgota;
if ((:head_shirota is null) or (:head_dolgota is null)) then
 begin
  EXCEPTION EXCEPTION_HEAD_GPS;
 end
    Select Max(shirota) From Alloc_Gps INTO :max_shirota;
    Select Min(shirota) From Alloc_Gps INTO :min_shirota;
    Select Max(dolgota) From Alloc_Gps INTO :max_dolgota;
    Select Min(dolgota) From Alloc_Gps INTO :min_dolgota;
--Центровка точки базы
    h1 = :max_shirota -  :head_shirota;
    h2 = :head_shirota - :min_shirota;
    d1 = :max_dolgota -  :head_dolgota;
    d2 = :head_dolgota - :min_dolgota;

    if (:h1 <> :h2) then
        begin
        if (:h1 > :h2) then --Растягиваем вниз
            begin
             min_shirota = :head_shirota - :h1;
            end
        if (:h1 < :h2) then --Растягиваем вверх
            begin
             max_shirota = :head_shirota + :h2;
            end
        end
    if (:d1 <> :d2) then
        begin
        if (:d1 > :d2) then --Растягиваем влево
            begin
             min_dolgota = :head_dolgota - :d1;
            end
        if (:d1 < :d2) then --Растягиваем вправо
            begin
             max_dolgota = :head_dolgota + :d2;
            end
        end
if (n_quad = 1) then
Select :max_shirota,(:max_dolgota-:min_dolgota)/2 + :min_dolgota,
            (:max_shirota-:min_shirota)/2 + :min_shirota, :max_dolgota FROM RDB$DATABASE INTO
    :a1, :a2, :a3, :a4;
if (n_quad = 2) then
Select :max_shirota,:min_dolgota,
            (:max_shirota-:min_shirota)/2 + :min_shirota, (:max_dolgota-:min_dolgota)/2 + :min_dolgota FROM RDB$DATABASE INTO
    :a1, :a2, :a3, :a4;
if (n_quad = 3) then
Select (:max_shirota-:min_shirota)/2 + :min_shirota,:min_dolgota,
            :min_shirota, (:max_dolgota-:min_dolgota)/2 + :min_dolgota FROM RDB$DATABASE INTO
    :a1, :a2, :a3, :a4;
if (n_quad = 4) then
Select (:max_shirota-:min_shirota)/2 + :min_shirota, (:max_dolgota-:min_dolgota)/2 + :min_dolgota,
            :min_shirota, :max_dolgota FROM RDB$DATABASE INTO
    :a1, :a2, :a3, :a4;

suspend;
end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_div_on_quad (sector INTEGER) --sector = 0 не бить на сектора
AS
 --Деление на квадраты рабочей области
declare variable id_alloc_gps  BIGINT;
declare variable max_shirota  DOUBLE PRECISION;
declare variable min_shirota  DOUBLE PRECISION;
declare variable max_dolgota  DOUBLE PRECISION;
declare variable min_dolgota  DOUBLE PRECISION;
declare variable head_shirota DOUBLE PRECISION;
declare variable head_dolgota DOUBLE PRECISION;
declare variable headquarters BIGINT;
declare variable h1 DOUBLE PRECISION;
declare variable h2 DOUBLE PRECISION;
declare variable d1 DOUBLE PRECISION;
declare variable d2 DOUBLE PRECISION;
declare variable is_inline INTEGER;
declare variable i         INTEGER;
declare variable x  NUMERIC(6,4);
declare variable y  NUMERIC(6,4);
declare variable x1 NUMERIC(6,4);
declare variable y1 NUMERIC(6,4);
declare variable x2 NUMERIC(6,4);
declare variable y2 NUMERIC(6,4);

begin
   Select cast(vlv as bigint) as v From Properties Where name = 'headquarters' ROWS 1 INTO :headquarters;
   Select ag.shirota, ag.dolgota From Alloc_Gps ag INNER JOIN Allocation a On a.id = ag.id_alloc
    Where a.id_cus = :headquarters  INTO :head_shirota, :head_dolgota;
if ((:head_shirota is null) or (:head_dolgota is null)) then
 begin
  EXCEPTION EXCEPTION_HEAD_GPS;
 end
    Select Max(shirota) From Alloc_Gps INTO :max_shirota;
    Select Min(shirota) From Alloc_Gps INTO :min_shirota;
    Select Max(dolgota) From Alloc_Gps INTO :max_dolgota;
    Select Min(dolgota) From Alloc_Gps INTO :min_dolgota;
--Центровка точки базы
    h1 = :max_shirota -  :head_shirota;
    h2 = :head_shirota - :min_shirota;
    d1 = :max_dolgota -  :head_dolgota;
    d2 = :head_dolgota - :min_dolgota;

    if (:h1 <> :h2) then
        begin
        if (:h1 > :h2) then --Растягиваем вниз
            begin
             min_shirota = :head_shirota - :h1;
            end
        if (:h1 < :h2) then --Растягиваем вверх
            begin
             max_shirota = :head_shirota + :h2;
            end
        end
    if (:d1 <> :d2) then
        begin
        if (:d1 > :d2) then --Растягиваем влево
            begin
             min_dolgota = :head_dolgota - :d1;
            end
        if (:d1 < :d2) then --Растягиваем вправо
            begin
             max_dolgota = :head_dolgota + :d2;
            end
        end
    --Делим на четыре квадрата, первый квадрат в верхнем правом углу, движемся против часовой
    Update Alloc_Gps Set quad = 1
        Where shirota >= (:max_shirota-:min_shirota)/2 + :min_shirota
             and dolgota >= (:max_dolgota-:min_dolgota)/2 + :min_dolgota;
    Update Alloc_Gps Set quad = 2
        Where shirota >= (:max_shirota-:min_shirota)/2 + :min_shirota
             and dolgota < (:max_dolgota-:min_dolgota)/2 + :min_dolgota;
    Update Alloc_Gps Set quad = 3
        Where shirota < (:max_shirota-:min_shirota)/2 + :min_shirota
             and dolgota < (:max_dolgota-:min_dolgota)/2 + :min_dolgota;
    Update Alloc_Gps Set quad = 4
        Where shirota < (:max_shirota-:min_shirota)/2 + :min_shirota
             and dolgota >= (:max_dolgota-:min_dolgota)/2 + :min_dolgota;

SELECT ROUND(:head_shirota, 4) FROM RDB$DATABASE INTO :x1;
SELECT ROUND(:head_dolgota, 4) FROM RDB$DATABASE INTO :y1;
SELECT ROUND(:max_shirota,  4) FROM RDB$DATABASE INTO :max_shirota;
SELECT ROUND(:max_dolgota,  4) FROM RDB$DATABASE INTO :max_dolgota;
SELECT ROUND(:min_shirota,  4) FROM RDB$DATABASE INTO :min_shirota;
SELECT ROUND(:min_dolgota,  4) FROM RDB$DATABASE INTO :min_dolgota;

if (:sector <> 0) then
begin
Update Alloc_Gps Set in_line = null Where 0=0;
--Квадрат 1====================================================================
SELECT ROUND((:max_shirota-:min_shirota)/2 + :min_shirota, 4) FROM RDB$DATABASE INTO :x2;
SELECT ROUND(:max_dolgota, 4) FROM RDB$DATABASE INTO :y2;
x2 = :x2 + 0.001;
i = 1;
while (:x2 < :max_shirota) Do
    begin
        FOR Select id, Round(shirota,4) as shirota, Round(dolgota,4) as dolgota
                From Alloc_Gps Where quad = 1 and in_line is null INTO :id_alloc_gps, :x, :y DO
            begin
             Select yes From p_point_in_line(:x1,:y1,:x2,:y2,:x,:y) INTO :is_inline;
                if (:is_inline = 1) then
                    begin
                     Update Alloc_Gps Set in_line = :i Where id = :id_alloc_gps;
                     i = :i + 1;
                    end
            end
     x2 = :x2 + 0.0001;
    end
SELECT ROUND(:max_shirota, 4) FROM RDB$DATABASE INTO :x2;
SELECT ROUND(:max_dolgota, 4) FROM RDB$DATABASE INTO :y2;
while (:y2 > :y1) Do
    begin
        FOR Select id, Round(shirota,4) as shirota, Round(dolgota,4) as dolgota
                From Alloc_Gps Where quad = 1 and in_line is null INTO :id_alloc_gps, :x, :y DO
            begin
             Select yes From p_point_in_line(:x1,:y1,:x2,:y2,:x,:y) INTO :is_inline;
                if (:is_inline = 1) then
                    begin
                     Update Alloc_Gps Set in_line = :i Where id = :id_alloc_gps;
                     i = :i + 1;
                    end
            end
     y2 = :y2 - 0.0001;
    end
--Квадрат 2====================================================================
SELECT ROUND(:max_shirota, 4) FROM RDB$DATABASE INTO :x2;
SELECT ROUND((:max_dolgota-:min_dolgota)/2 + :min_dolgota, 4) FROM RDB$DATABASE INTO :y2;
y2 = :y2 - 0.001;
i = 1;
while (:y2 > :min_dolgota) Do
    begin
        FOR Select id, Round(shirota,4) as shirota, Round(dolgota,4) as dolgota
                From Alloc_Gps Where quad = 2 and in_line is null INTO :id_alloc_gps, :x, :y DO
            begin
             Select yes From p_point_in_line(:x1,:y1,:x2,:y2,:x,:y) INTO :is_inline;
                if (:is_inline = 1) then
                    begin
                     Update Alloc_Gps Set in_line = :i Where id = :id_alloc_gps;
                     i = :i + 1;
                    end
            end
     y2 = :y2 - 0.0001;
    end
SELECT ROUND(:max_shirota, 4) FROM RDB$DATABASE INTO :x2;
SELECT ROUND(:min_dolgota, 4) FROM RDB$DATABASE INTO :y2;
while (:x2 > :x1) Do
    begin
        FOR Select id, Round(shirota,4) as shirota, Round(dolgota,4) as dolgota
                From Alloc_Gps Where quad = 2 and in_line is null INTO :id_alloc_gps, :x, :y DO
            begin
             Select yes From p_point_in_line(:x1,:y1,:x2,:y2,:x,:y) INTO :is_inline;
                if (:is_inline = 1) then
                    begin
                     Update Alloc_Gps Set in_line = :i Where id = :id_alloc_gps;
                     i = :i + 1;
                    end
            end
     x2 = :x2 - 0.0001;
    end
--Квадрат 3====================================================================
SELECT ROUND((:max_shirota-:min_shirota)/2 + :min_shirota, 4) FROM RDB$DATABASE INTO :x2;
SELECT ROUND(:min_dolgota, 4) FROM RDB$DATABASE INTO :y2;
x2 = :x2 - 0.001;
i = 1;
while (:x2 > :min_shirota) Do
    begin
        FOR Select id, Round(shirota,4) as shirota, Round(dolgota,4) as dolgota
                From Alloc_Gps Where quad = 3 and in_line is null INTO :id_alloc_gps, :x, :y DO
            begin
             Select yes From p_point_in_line(:x1,:y1,:x2,:y2,:x,:y) INTO :is_inline;
                if (:is_inline = 1) then
                    begin
                     Update Alloc_Gps Set in_line = :i Where id = :id_alloc_gps;
                     i = :i + 1;
                    end
            end
     x2 = :x2 - 0.0001;
    end
SELECT ROUND(:min_shirota, 4) FROM RDB$DATABASE INTO :x2;
SELECT ROUND(:min_dolgota, 4) FROM RDB$DATABASE INTO :y2;
while (:y2 < :y1) Do
    begin
        FOR Select id, Round(shirota,4) as shirota, Round(dolgota,4) as dolgota
                From Alloc_Gps Where quad = 3 and in_line is null INTO :id_alloc_gps, :x, :y DO
            begin
             Select yes From p_point_in_line(:x1,:y1,:x2,:y2,:x,:y) INTO :is_inline;
                if (:is_inline = 1) then
                    begin
                     Update Alloc_Gps Set in_line = :i Where id = :id_alloc_gps;
                     i = :i + 1;
                    end
            end
     y2 = :y2 + 0.0001;
    end
--Квадрат 4====================================================================
SELECT ROUND(:min_shirota, 4) FROM RDB$DATABASE INTO :x2;
SELECT ROUND((:max_dolgota-:min_dolgota)/2 + :min_dolgota, 4) FROM RDB$DATABASE INTO :y2;
y2 = :y2 + 0.001;
i = 1;
while (:y2 < :max_dolgota) Do
    begin
        FOR Select id, Round(shirota,4) as shirota, Round(dolgota,4) as dolgota
                From Alloc_Gps Where quad = 4 and in_line is null INTO :id_alloc_gps, :x, :y DO
            begin
             Select yes From p_point_in_line(:x1,:y1,:x2,:y2,:x,:y) INTO :is_inline;
                if (:is_inline = 1) then
                    begin
                     Update Alloc_Gps Set in_line = :i Where id = :id_alloc_gps;
                     i = :i + 1;
                    end
            end
     y2 = :y2 + 0.0001;
    end
SELECT ROUND(:min_shirota, 4) FROM RDB$DATABASE INTO :x2;
SELECT ROUND(:max_dolgota, 4) FROM RDB$DATABASE INTO :y2;
while (:x2 < :x1) Do
    begin
        FOR Select id, Round(shirota,4) as shirota, Round(dolgota,4) as dolgota
                From Alloc_Gps Where quad = 4 and in_line is null INTO :id_alloc_gps, :x, :y DO
            begin
             Select yes From p_point_in_line(:x1,:y1,:x2,:y2,:x,:y) INTO :is_inline;
                if (:is_inline = 1) then
                    begin
                     Update Alloc_Gps Set in_line = :i Where id = :id_alloc_gps;
                     i = :i + 1;
                    end
            end
     x2 = :x2 + 0.0001;
    end
end
--================================================================================================
end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_add_zero
AS
 --В Exel пропали лидирующие нули, добавляем
declare variable s_id  VARCHAR(15);
declare variable  id_cross VARCHAR(25);
declare variable id integer;
declare variable p integer;

begin
     FOR SELECT g.id, g.id_cross
        FROM import_gps g
               INTO :id, :id_cross
               do
                begin
                 SELECT CHAR_LENGTH(TRIM(:id_cross)) FROM RDB$DATABASE INTO :p;
                  IF (:p = 1) THEN
                      s_id = '0000'||:id_cross;
                  IF (:p = 2) THEN
                      s_id = '000'||:id_cross;
                  IF (:p = 3) THEN
                      s_id = '00'||:id_cross;
                  IF (:p = 4) THEN
                      s_id = '0'||:id_cross;

                  Update import_gps Set id_cross = :s_id Where id = :id;
                end 

end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_import_ray
AS
--DECLARE VARIABLE data DATE;
DECLARE VARIABLE  ID_CUS        BIGINT;
DECLARE VARIABLE  ID_ALLOC      BIGINT;
DECLARE VARIABLE  ID_CROSS      VARCHAR(25);
DECLARE VARIABLE  NAME          VARCHAR(75);
DECLARE VARIABLE  R             VARCHAR(45);

begin
  FOR SELECT      ID_CROSS, NAME, R
        FROM Import_Ray r
               INTO :id_cross, :name, :r
              do
              begin
               Select id_cus From Customers_Cross Where id_cus_cross = TRIM(:id_cross)
                 INTO :id_cus;

                  Select id From allocation Where name Like Trim(:r) || '%' 
                    Rows 1 Into :id_alloc;
                    Update allocation Set parent = :id_alloc Where id_cus = :id_cus;

              end
end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_import_reg
AS
--DECLARE VARIABLE data DATE;
DECLARE VARIABLE  ID_CUS        BIGINT;
DECLARE VARIABLE  ID_ALLOC      BIGINT;
DECLARE VARIABLE  ID_CROSS      VARCHAR(25);
DECLARE VARIABLE  NAME          VARCHAR(75);
DECLARE VARIABLE  R             VARCHAR(5);
begin
  FOR SELECT      ID_CROSS, NAME, R
        FROM Import_Reg r
               INTO :id_cross, :name, :r
              do
              begin
               Select id_cus From Customers_Cross Where id_cus_cross = TRIM(:id_cross)
                 INTO :id_cus;
                  if (:r ='Д' or :r ='д' ) then
                   begin
                    Update allocation Set parent = 20000000004 Where id_cus = :id_cus;
                   end
                  if (:r ='М' or :r ='м' ) then
                   begin
                    Update allocation Set parent = 20000000005 Where id_cus = :id_cus;
                   end
                  if (:r ='О' or :r ='о' ) then
                   begin
                    Update allocation Set parent = 20000000003 Where id_cus = :id_cus;
                   end

              end
end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_graf_ord
AS
DECLARE VARIABLE  ID             BIGINT;
DECLARE VARIABLE  CNT            INTEGER;
DECLARE VARIABLE  START_P        INTEGER;
DECLARE VARIABLE  END_P          INTEGER;
DECLARE VARIABLE  ORD            INTEGER;

begin
ord = 1;
     Select id, start_p, end_p From tmp_matrix_littl_graf Where start_p = :ord
        INTO :id, :start_p, :end_p;
Update tmp_matrix_littl_graf Set ord = :ord Where id = :id;
    Select count(id) From tmp_matrix_littl_graf INTO :cnt;
  While (cnt <> 1) Do
    begin
     ord = :ord + 1;
     Select id, start_p, end_p From tmp_matrix_littl_graf Where start_p = :end_p
        INTO :id, :start_p, :end_p;
     Update tmp_matrix_littl_graf Set ord = :ord Where id = :id;
     cnt =  :cnt - 1;
    end
For Select ord, start_p From tmp_matrix_littl_graf INTO :ord, :start_p DO
    begin
      Update tmp_matrix_littl_graf1 Set ord = :ord  Where id = :start_p;
    end


end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_ymaps_route (
    id_task bigint)
AS
DECLARE VARIABLE lat1 DOUBLE PRECISION;
DECLARE VARIABLE long1 DOUBLE PRECISION;
DECLARE VARIABLE lat2 DOUBLE PRECISION;
DECLARE VARIABLE long2 DOUBLE PRECISION;
DECLARE VARIABLE  ID             BIGINT;
DECLARE VARIABLE  ID_VH          BIGINT;
DECLARE VARIABLE  ID_VH1         BIGINT;
DECLARE VARIABLE  HEADQUARTERS   BIGINT;
DECLARE VARIABLE  SUMMA          NUMERIC(18,5);
DECLARE VARIABLE  WGT            NUMERIC(18,5);
DECLARE VARIABLE  MEST           NUMERIC(18,5);
DECLARE VARIABLE  MEST_KEG       NUMERIC(18,5);
DECLARE VARIABLE  DISTANCE       DOUBLE PRECISION;
DECLARE VARIABLE  TIME_ON         NUMERIC(10,2);
DECLARE VARIABLE  SPEED          INTEGER;    
DECLARE VARIABLE  DIST           DOUBLE PRECISION;
DECLARE VARIABLE  DISTANCE_LIMIT DOUBLE PRECISION;
DECLARE VARIABLE  VSEGO_DISTANCE DOUBLE PRECISION;
DECLARE VARIABLE  VSEGO_OBJECTS_WGT NUMERIC(18,5);
DECLARE VARIABLE  VSEGO_VEHICLE_WGT NUMERIC(18,5);
DECLARE VARIABLE  VEHICLE_WGT    NUMERIC(18,5);
DECLARE VARIABLE  VH_LOAD_KG     NUMERIC(18,5);
DECLARE VARIABLE  SHIROTA        DOUBLE PRECISION;
DECLARE VARIABLE  DOLGOTA        DOUBLE PRECISION;
DECLARE VARIABLE  HEAD_SHIROTA   DOUBLE PRECISION;
DECLARE VARIABLE  HEAD_DOLGOTA   DOUBLE PRECISION;
DECLARE VARIABLE  ID_TO          BIGINT;
DECLARE VARIABLE  TO_NAME        VARCHAR(75);
DECLARE VARIABLE  ID_ALLOC_TO    BIGINT;
DECLARE VARIABLE  TO_ALLOC_NAME  VARCHAR(175);
DECLARE VARIABLE  CNT            INTEGER;
DECLARE VARIABLE  XODKA          INTEGER;
DECLARE VARIABLE  is_tbl         INTEGER;
DECLARE VARIABLE  ROUTE          INTEGER;
DECLARE VARIABLE  I              INTEGER;
DECLARE VARIABLE  I1             INTEGER;
DECLARE VARIABLE  STROKECOLOR    VARCHAR(25);
DECLARE VARIABLE  POINTCOLOR     VARCHAR(25);
DECLARE VARIABLE  PRESET         VARCHAR(6);
DECLARE VARIABLE  TWIRL          VARCHAR(6);
DECLARE VARIABLE  STRETCHYICON   VARCHAR(12);
begin
route = 1;
preset = 'preset';
TWIRL = 'twirl#';
STRETCHYICON = 'StretchyIcon';
DELETE FROM YMAPS_ROUTE;
Select Max(xodka) From Task_Transp_Elements INTO :xodka;
WHILE (:xodka <> 0) DO
  begin
    FOR Select DISTINCT id_vh From Task_Transp_Elements INTO :id_vh DO
        begin
         i = 0;
         FOR Select  te.shirota, te.dolgota
            From Task_Transp_Elements te
                Where te.id_head <> -1 and te.id_vh = :id_vh and te.xodka = :xodka
                            INTO :shirota, :dolgota DO
            begin
                if (:i = 0 ) then
                begin
                    if (:route <> 1 ) then
                        begin
                                SELECT c_h From Colors Where id = :route INTO :strokecolor;
                                SELECT c_e From Colors Where id = :route INTO :pointcolor;
                                INSERT INTO YMAPS_ROUTE (id, id_vh, route, txt )
                                    VALUES (GEN_ID(GEN_Task_Transp_Elements_ID, 1), :id_vh, :route -1,
                                        'END TEXT'||'], {mapStateAutoApply: true}).then(function (router) {'
                            ||' route = router;'||' route.options.set({ strokeColor:' || :strokecolor ||' , opacity: 0.9 });'
                            ||'myMap.geoObjects.add(route);'||' var points = route.getWayPoints();'
                            --||'points.options.set('|| :preset ||', '||:twirl ||:pointcolor||:StretchyIcon||');'
                            ||' }, function (error) { ' || ' alert("Error: " + error.message);});'
            
                            );
                        end
                    INSERT INTO YMAPS_ROUTE (id, id_vh, route, txt )
                        VALUES (GEN_ID(GEN_Task_Transp_Elements_ID, 1), :id_vh, :route,
                            'ymaps.route([');
                end
                INSERT INTO YMAPS_ROUTE (id, id_vh, route, txt )
                    VALUES (GEN_ID(GEN_Task_Transp_Elements_ID, 1), :id_vh, :route,
                        '["' || cast(:shirota as varchar(16)) || ', '||
                               cast(:dolgota as varchar(16)) || '"],');
             i = :i + 1;
            end
          if (:i > 0) then route = :route + 1;
          if (:route > 7) then
           begin
                                SELECT c_h From Colors Where id = :route INTO :strokecolor;
                                SELECT c_e From Colors Where id = :route INTO :pointcolor;
                                INSERT INTO YMAPS_ROUTE (id, id_vh, route, txt )
                                    VALUES (GEN_ID(GEN_Task_Transp_Elements_ID, 1), :id_vh, :route -1,
                                        'END TEXT'||'], {mapStateAutoApply: true}).then(function (router) {'
                            ||' route = router;'||' route.options.set({ strokeColor:' || :strokecolor ||' , opacity: 0.9 });'
                            ||'myMap.geoObjects.add(route);'||' var points = route.getWayPoints();'
                            --||'points.options.set('|| :preset ||', '|| :twirl || ' || :pointcolor ||' || :StretchyIcon ||');'
                            ||' }, function (error) { ' || ' alert("Error: " + error.message);});'
            
                            );
             route = 1;
           end

        end
        
   xodka = :xodka -1;
  end
end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_distance_gps(Lat1 DOUBLE PRECISION, Long1 DOUBLE PRECISION,
                                            Lat2 DOUBLE PRECISION, Long2 DOUBLE PRECISION)
 RETURNS (
    RESULT DOUBLE PRECISION)
AS
/*$$IBEC$$ declare variable Lat1 DOUBLE PRECISION;
declare variable Lat2 DOUBLE PRECISION;
declare variable Long1 DOUBLE PRECISION;
declare variable Long2 DOUBLE PRECISION;
 $$IBEC$$*/
declare variable PI_    DOUBLE PRECISION;
declare variable deltaLong DOUBLE PRECISION;
declare variable deltaLat DOUBLE PRECISION;
declare variable sindeltaLong DOUBLE PRECISION;
declare variable cosdeltaLong DOUBLE PRECISION;
declare variable Angledelta DOUBLE PRECISION;
declare variable cosLat1 DOUBLE PRECISION;
declare variable cosLat2 DOUBLE PRECISION;
declare variable sinLong1 DOUBLE PRECISION;
declare variable sinLong2 DOUBLE PRECISION;
declare variable sinLat1 DOUBLE PRECISION;
declare variable sinLat2 DOUBLE PRECISION;
declare variable CHD DOUBLE PRECISION;
declare variable CHS DOUBLE PRECISION;
begin
    PI_=    3.1415926536;
/*$$IBEC$$     Lat1 =  47.87532;
    Lat2 =  47.886151;
    Long1 = 37.346881;
    Long2 = 37.305472; $$IBEC$$*/

    Lat1=(:Lat1*:PI_)/180;
    Lat2=(:Lat2*:PI_)/180;
    Long1=(:Long1*:PI_)/180;
    Long2=(:Long2*:PI_)/180;
    SELECT cos(:Lat1) FROM RDB$DATABASE INTO :cosLat1;
    SELECT cos(:Lat2) FROM RDB$DATABASE INTO :cosLat2;
    SELECT sin(:Long1) FROM RDB$DATABASE INTO :sinLong1;
    SELECT sin(:Long2) FROM RDB$DATABASE INTO :sinLong2;
    SELECT sin(:Lat1) FROM RDB$DATABASE INTO :sinLat1;
    SELECT sin(:Lat2) FROM RDB$DATABASE INTO :sinLat2;
    CHD=:Long2-:Long1;
    SELECT Abs(:CHD) FROM RDB$DATABASE INTO :deltaLong;
    CHS=:Lat2-:Lat1;
    SELECT Abs(:CHS) FROM RDB$DATABASE INTO :deltaLat;
    sindeltaLong=sin(:Long2-:Long1);
    cosdeltaLong=cos(:deltaLong);

--Сферическая теорема косинусов
SELECT acos(:sinLat1*:sinLat2+:cosLat1*:cosLat2*:cosdeltaLong) FROM RDB$DATABASE INTO :Angledelta;
    SELECT 6372795*:Angledelta FROM RDB$DATABASE
    INTO :RESULT;
  suspend;
end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_task_ord_feodos (
    ID_TASK BIGINT)
AS
DECLARE VARIABLE  ID_VH      BIGINT;
DECLARE VARIABLE  ID              BIGINT;
DECLARE VARIABLE  I              INTEGER;
DECLARE VARIABLE lat1 DOUBLE PRECISION;
DECLARE VARIABLE long1 DOUBLE PRECISION;
DECLARE VARIABLE lat2 DOUBLE PRECISION;
DECLARE VARIABLE long2 DOUBLE PRECISION;
DECLARE VARIABLE  HEAD_SHIROTA   DOUBLE PRECISION;
DECLARE VARIABLE  HEAD_DOLGOTA   DOUBLE PRECISION;
DECLARE VARIABLE  HEADQUARTERS   BIGINT;
DECLARE VARIABLE  DISTANCE       DOUBLE PRECISION;


begin
   Select cast(vlv as bigint) as v From Properties Where name = 'headquarters' ROWS 1 INTO :headquarters;
   head_shirota = null; head_dolgota = null;
   Select ag.shirota, ag.dolgota From Alloc_Gps ag INNER JOIN Allocation a On a.id = ag.id_alloc
    Where a.id_cus = :headquarters  INTO :head_shirota, :head_dolgota;
if ((:head_shirota is null) or (:head_dolgota is null)) then
 begin
  EXCEPTION EXCEPTION_HEAD_GPS;
 end

FOR Select te.id_vh From task_transp_elements te
    Where te.id_task = :ID_TASK
    Group by te.id_vh
    INTO :ID_VH DO
    begin
         i = 2;
         lat1 = :head_shirota; -- Сюда координаты точки старта
         long1 = :head_dolgota;
         lat2 = null;
         long2 = null;
        FOR Select te.id, te.shirota, te.dolgota From task_transp_elements te
            Where te.id_task = :ID_TASK and te.id_vh = :id_vh and te.quad = 1 ORDER by te.dolgota
            INTO :ID, :lat2, :long2 DO
            begin
                         if ((:lat1 <> :lat2) and (:long1 <> :long2)) then
                           begin
                             Select Result From p_distance_gps(:lat1, :long1, :lat2, :long2)
                              INTO :distance;
                             lat1 = :lat2;
                             long1 = :long2;
                           end
                         else
                          begin
                            distance = 0.00;
                          end
              Update task_transp_elements te Set te.ord = :i, te.distance = :distance Where te.id = :id;
              i = :i + 1;
            end
         i = 2;
         lat1 = :head_shirota; -- Сюда координаты точки старта
         long1 = :head_dolgota;
         lat2 = null;
         long2 = null;
        FOR Select te.id, te.shirota, te.dolgota From task_transp_elements te
            Where te.id_task = :ID_TASK and te.id_vh = :id_vh and te.quad = 2 ORDER by te.dolgota DESC
            INTO :ID, :lat2, :long2 DO
            begin
                         if ((:lat1 <> :lat2) and (:long1 <> :long2)) then
                           begin
                             Select Result From p_distance_gps(:lat1, :long1, :lat2, :long2)
                              INTO :distance;
                             lat1 = :lat2;
                             long1 = :long2;
                           end
                         else
                          begin
                            distance = 0.00;
                          end
              Update task_transp_elements te Set te.ord = :i, te.distance = :distance Where te.id = :id;
              i = :i + 1;
            end
         i = 2;
         lat1 = :head_shirota; -- Сюда координаты точки старта
         long1 = :head_dolgota;
         lat2 = null;
         long2 = null;
        FOR Select te.id, te.shirota, te.dolgota From task_transp_elements te
            Where te.id_task = :ID_TASK and te.id_vh = :id_vh and (te.quad in (3,4)) ORDER by te.dolgota DESC
            INTO :ID, :lat2, :long2 DO
            begin
                         if ((:lat1 <> :lat2) and (:long1 <> :long2)) then
                           begin
                             Select Result From p_distance_gps(:lat1, :long1, :lat2, :long2)
                              INTO :distance;
                             lat1 = :lat2;
                             long1 = :long2;
                           end
                         else
                          begin
                            distance = 0.00;
                          end
              Update task_transp_elements te Set te.ord = :i, te.distance = :distance Where te.id = :id;
              i = :i + 1;
            end
    end

end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_update_dist(
    id_task BIGINT)
AS
DECLARE VARIABLE  ID_VH          BIGINT;
DECLARE VARIABLE  ID             BIGINT;
DECLARE VARIABLE  XODKA_STR      VARCHAR(15);
DECLARE VARIABLE  lat1           DOUBLE PRECISION;
DECLARE VARIABLE  long1          DOUBLE PRECISION;
DECLARE VARIABLE  lat2           DOUBLE PRECISION;
DECLARE VARIABLE  long2          DOUBLE PRECISION;
DECLARE VARIABLE  HEAD_SHIROTA   DOUBLE PRECISION;
DECLARE VARIABLE  HEAD_DOLGOTA   DOUBLE PRECISION;
DECLARE VARIABLE  HEADQUARTERS   BIGINT;
DECLARE VARIABLE  DISTANCE       DOUBLE PRECISION;


begin
   Select cast(vlv as bigint) as v From Properties Where name = 'headquarters' ROWS 1 INTO :headquarters;
   head_shirota = null; head_dolgota = null;
   Select ag.shirota, ag.dolgota From Alloc_Gps ag INNER JOIN Allocation a On a.id = ag.id_alloc
    Where a.id_cus = :headquarters  INTO :head_shirota, :head_dolgota;
if ((:head_shirota is null) or (:head_dolgota is null)) then
 begin
  EXCEPTION EXCEPTION_HEAD_GPS;
 end

FOR Select te.id_vh, te.xodka From task_transp_elements te
    Where te.id_task = :ID_TASK
    Group by te.id_vh, te.xodka
    INTO :ID_VH, :XODKA_STR DO
    begin
         lat1 = :head_shirota; -- Сюда координаты точки старта
         long1 = :head_dolgota;
         lat2 = null;
         long2 = null;
        FOR Select te.id, te.shirota, te.dolgota From task_transp_elements te
            Where te.id_task = :ID_TASK and te.id_vh = :id_vh and te.xodka = :XODKA_STR ORDER by te.ord
            INTO :ID, :lat2, :long2 DO
            begin
                         if ((:lat1 <> :lat2) and (:long1 <> :long2)) then
                           begin
                             Select Result From p_distance_gps(:lat1, :long1, :lat2, :long2)
                              INTO :distance;
                             lat1 = :lat2;
                             long1 = :long2;
                           end
                         else
                          begin
                            distance = 0.00;
                          end
              Update task_transp_elements te Set te.distance = :distance Where te.id = :id;
            end
    end
end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_matrix_littl (
    id_vh BIGINT,
    xodka VARCHAR(10),
    id_task BIGINT)
AS
DECLARE VARIABLE  ID             BIGINT;
DECLARE VARIABLE  I              INTEGER;
DECLARE VARIABLE  J              INTEGER;
DECLARE VARIABLE  CNT            INTEGER;
DECLARE VARIABLE  COUNT_GRAF     INTEGER;
DECLARE VARIABLE  CNT_all        INTEGER;
DECLARE VARIABLE  CNT0           INTEGER;
DECLARE VARIABLE  START_POINT        INTEGER;
DECLARE VARIABLE  END_POINT          INTEGER;
DECLARE VARIABLE  ORD            INTEGER;
DECLARE VARIABLE  ID_TMP         INTEGER;
DECLARE VARIABLE  J_VLV          INTEGER;
DECLARE VARIABLE lat1 DOUBLE PRECISION;
DECLARE VARIABLE long1 DOUBLE PRECISION;
DECLARE VARIABLE lat2 DOUBLE PRECISION;
DECLARE VARIABLE long2 DOUBLE PRECISION;
DECLARE VARIABLE  SHIROTA        DOUBLE PRECISION;
DECLARE VARIABLE  DOLGOTA        DOUBLE PRECISION;
DECLARE VARIABLE  HEAD_SHIROTA   DOUBLE PRECISION;
DECLARE VARIABLE  HEAD_DOLGOTA   DOUBLE PRECISION;
DECLARE VARIABLE  HEADQUARTERS   BIGINT;
DECLARE VARIABLE distance DOUBLE PRECISION;
DECLARE VARIABLE EXEC_STR VARCHAR(4000);

begin

Delete From tmp_matrix_littl_graf1 Where 0 = 0;
Delete From matrix_littl Where 0 = 0;
Select cast(vlv as bigint) as v From Properties Where name = 'headquarters' ROWS 1 INTO :headquarters;
i = 1;
--Точка базы
   Select ag.shirota, ag.dolgota From Alloc_Gps ag INNER JOIN Allocation a On a.id = ag.id_alloc
    Where a.id_cus = :headquarters  INTO :head_shirota, :head_dolgota;
if ((:head_shirota is null) or (:head_dolgota is null)) then
 begin
  EXCEPTION EXCEPTION_HEAD_GPS;
 end
Insert INTO tmp_matrix_littl_graf1 (id, id_te, shirota, dolgota)
    Values (:i, -1, :head_shirota, :head_dolgota);
i = :i + 1;
FOR Select te.id, te.shirota, te.dolgota From task_transp_elements te
    Where te.id_head <> -1 and te.id_vh  = :id_vh and te.xodka = :xodka and te.id_task = :id_task INTO :id, :shirota, :dolgota DO
 begin
        Insert INTO tmp_matrix_littl_graf1 (id, id_te, shirota, dolgota)
            Values (:i, :id, :shirota, :dolgota);
  i = :i + 1;
 end

/*$$IBEC$$ Insert INTO tmp_matrix_littl_graf1 (id, shirota, dolgota)
    Values (2, 47.838584, 37.10508);
Insert INTO tmp_matrix_littl_graf1 (id, shirota, dolgota)
    Values (3, 47.838589, 37.105024);
Insert INTO tmp_matrix_littl_graf1 (id, shirota, dolgota)
    Values (4, 47.839167, 36.833305);
Insert INTO tmp_matrix_littl_graf1 (id, shirota, dolgota)
    Values (5, 47.840034, 36.839227);
Insert INTO tmp_matrix_littl_graf1 (id, shirota, dolgota)
    Values (6, 47.848123, 36.831416); $$IBEC$$*/

SELECT  Count(id) From tmp_matrix_littl_graf1 INTO :count_graf;

start_point = 1;
end_point = 1;
cnt_all = :count_graf;
cnt = :count_graf;

 WHILE (cnt_all <> 0) Do   -- Внешний цикл ///////////////////////////////
  begin
    exec_str = 'INSERT INTO MATRIX_LITTL (id, j' || cast(:start_point as varchar(3)) || ')' ||
                    ' Values (' || cast(:start_point as varchar(3)) || ', -888' || ')';
    execute statement exec_str;
    WHILE (cnt <> 0) Do -- Значения в каждый столбец
     begin
        SELECT  shirota, dolgota From tmp_matrix_littl_graf1 Where id = :start_point     INTO :lat1, :long1;
        SELECT  shirota, dolgota From tmp_matrix_littl_graf1 Where id = :end_point       INTO :lat2, :long2;
        if ((:lat1 = :lat2) and (:long1 = :long2)) then
         distance = 0;
        else Select Result From p_distance_gps(:lat1, :long1, :lat2, :long2)
                                  INTO :distance;
    
        exec_str = 'UPDATE MATRIX_LITTL SET j' || cast((:end_point)  as varchar(3)) || ' = ' || 'COALESCE(j' || cast((:end_point)  as varchar(3)) || ',0) + '
                        || cast(:distance as varchar(39))|| ' Where ID = ' || cast(:start_point as varchar(3));
        execute statement exec_str;
        end_point = :end_point + 1;
        cnt =  :cnt - 1;
     end
     start_point = :start_point + 1;
     cnt_all = :cnt_all - 1;
     cnt = :count_graf;
     end_point = 1;
 end
end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_task_transportation (
    data1 DATE,
    data2 DATE,
    first_load_keg INTEGER)
AS
DECLARE VARIABLE lat1 DOUBLE PRECISION;
DECLARE VARIABLE long1 DOUBLE PRECISION;
DECLARE VARIABLE lat2 DOUBLE PRECISION;
DECLARE VARIABLE long2 DOUBLE PRECISION;
DECLARE VARIABLE id BIGINT;
DECLARE VARIABLE id_task BIGINT;
DECLARE VARIABLE id_vh BIGINT;
DECLARE VARIABLE headquarters BIGINT;
DECLARE VARIABLE summa NUMERIC(18,5);
DECLARE VARIABLE wgt NUMERIC(18,5);
DECLARE VARIABLE mest NUMERIC(18,5);
DECLARE VARIABLE mest_keg NUMERIC(18,5);
DECLARE VARIABLE distance DOUBLE PRECISION;
DECLARE VARIABLE time_on NUMERIC(10,2);
DECLARE VARIABLE speed INTEGER;
DECLARE VARIABLE circle INTEGER;
DECLARE VARIABLE distance_limit DOUBLE PRECISION;
DECLARE VARIABLE time_on_limit NUMERIC(10,2);
DECLARE VARIABLE time_on_unload NUMERIC(10,2);
DECLARE VARIABLE vsego_distance DOUBLE PRECISION;
DECLARE VARIABLE vsego_time_on NUMERIC(10,2);
DECLARE VARIABLE vsego_objects_wgt NUMERIC(18,5);
DECLARE VARIABLE vsego_vehicle_wgt NUMERIC(18,5);
DECLARE VARIABLE vehicle_wgt NUMERIC(18,5);
DECLARE VARIABLE vh_load_kg NUMERIC(18,5);
DECLARE VARIABLE shirota DOUBLE PRECISION;
DECLARE VARIABLE dolgota DOUBLE PRECISION;
DECLARE VARIABLE head_shirota DOUBLE PRECISION;
DECLARE VARIABLE head_dolgota DOUBLE PRECISION;
DECLARE VARIABLE id_to BIGINT;
DECLARE VARIABLE to_name VARCHAR(75);
DECLARE VARIABLE point VARCHAR(75);
DECLARE VARIABLE id_alloc_to BIGINT;
DECLARE VARIABLE to_alloc_name VARCHAR(175);
DECLARE VARIABLE cnt INTEGER;
DECLARE VARIABLE xodka INTEGER;
DECLARE VARIABLE xodka_limit INTEGER;
DECLARE VARIABLE xodka_str VARCHAR(15);
DECLARE VARIABLE quad INTEGER;
DECLARE VARIABLE q1_wgt NUMERIC(10,2);
DECLARE VARIABLE q2_wgt NUMERIC(10,2);
DECLARE VARIABLE q3_wgt NUMERIC(10,2);
DECLARE VARIABLE q4_wgt NUMERIC(10,2);
DECLARE VARIABLE in_line INTEGER;
DECLARE VARIABLE circle_start INTEGER;
DECLARE VARIABLE circle_end INTEGER;
DECLARE VARIABLE full_load INTEGER;
DECLARE VARIABLE id_region BIGINT;
DECLARE VARIABLE i  INTEGER;
DECLARE VARIABLE qq INTEGER;
DECLARE VARIABLE get_on_board INTEGER;
DECLARE VARIABLE over_load_vh INTEGER;
DECLARE VARIABLE auto_select_vh INTEGER;
DECLARE VARIABLE max_distance DOUBLE PRECISION;
begin
id_task = null;
Select id From Task_Transportation Where data = :data2 ROWS 1 INTO :id_task;


Delete From Task_Transp_Elements Where id_task = :id_task;
Select id From Task_Transportation Where id = :id_task INTO :id_task;
if (:id_task is null) then
 begin
   id_task = GEN_ID(GEN_Task_Transportation_ID, 1);
   INSERT INTO Task_Transportation (id, data) VALUES (:id_task, :data2);
 end
   Select cast(vlv as bigint) as v From Properties Where name = 'headquarters' ROWS 1 INTO :headquarters;
   Select cast(vlv as double precision) as v From Properties Where name = 'distance_limit' ROWS 1 INTO :distance_limit;
   Select cast(vlv as NUMERIC(10,2)) as v From Properties Where name = 'time_on_limit' ROWS 1 INTO :time_on_limit;
   Select cast(vlv as NUMERIC(10,2)) as v From Properties Where name = 'time_on_unload' ROWS 1 INTO :time_on_unload;
   Select cast(vlv as INTEGER) as v From Properties Where name = 'over_load_vh' ROWS 1 INTO :over_load_vh;
   Select cast(vlv as INTEGER) as v From Properties Where name = 'auto_select_vh' ROWS 1 INTO :auto_select_vh;
   head_shirota = null; head_dolgota = null;
   Select ag.shirota, ag.dolgota From Alloc_Gps ag INNER JOIN Allocation a On a.id = ag.id_alloc
    Where a.id_cus = :headquarters  INTO :head_shirota, :head_dolgota;
if ((:head_shirota is null) or (:head_dolgota is null)) then
 begin
  EXCEPTION EXCEPTION_HEAD_GPS;
 end
   Select Count(id) From Vehicle_Online Where id_task = :id_task INTO :cnt;
if ((:cnt <=0) and (auto_select_vh =0)) then
 begin
  EXCEPTION EXCEPTION_NOT_VH_ONLINE;
 end

Update Vehicle_Online Set id_task = :id_task Where data = :data1;
--Квадрат 1 справа на лево -------------------------------------------------------------------------------
 FOR Select h.id, h.summa, h.wgt, h.mest, h.mest_keg, agt.shirota, agt.dolgota, agt.quad, agt.in_line,
            h.id_to, h.to_name, h.id_alloc_to, h.to_alloc_name, a.parent as id_region, h.point
        From v_Headers h
                    Inner Join Alloc_Gps agt On h.id_alloc_to = agt.id_alloc
                    Inner Join Allocation a On a.id = agt.id_alloc
    Where h.id_from = :headquarters  and h.data BETWEEN :data1 and :data2
        and agt.quad = 1
        Order by agt.in_line, agt.dolgota DESC
                --Order by agt.shirota
            INTO  :id, :summa, :wgt, :mest, :mest_keg, :shirota, :dolgota, :quad, :in_line, :id_to, :to_name,
            :id_alloc_to, :to_alloc_name, :id_region, :point
            do
            begin
             Insert INTO Task_Transp_Elements (id, id_task, id_head, summa, wgt, mest, mest_keg ,
                shirota, dolgota, quad, in_line,
                id_to, to_name, id_alloc_to, to_alloc_name, id_region, point)
                    Values (GEN_ID(GEN_Task_Transp_Elements_ID, 1), :id_task, :id, :summa, :wgt, :mest, :mest_keg,
                    :shirota, :dolgota, :quad, :in_line, :id_to, :to_name,
                                :id_alloc_to, :to_alloc_name, :id_region, :point);
            end
--Квадрат 2 справа на лево -------------------------------------------------------------------------------
 FOR Select h.id, h.summa, h.wgt, h.mest, h.mest_keg, agt.shirota, agt.dolgota, agt.quad, agt.in_line,
            h.id_to, h.to_name, h.id_alloc_to, h.to_alloc_name, a.parent as id_region, h.point
        From v_Headers h
                    Inner Join Alloc_Gps agt On h.id_alloc_to = agt.id_alloc
                    Inner Join Allocation a On a.id = agt.id_alloc
    Where h.id_from = :headquarters  and h.data BETWEEN :data1 and :data2
        and agt.quad = 2
        Order by agt.in_line, agt.dolgota DESC
          --Order by agt.shirota
            INTO  :id, :summa, :wgt, :mest, :mest_keg, :shirota, :dolgota, :quad, :in_line, :id_to, :to_name,
            :id_alloc_to, :to_alloc_name, :id_region, :point
            do
            begin
             Insert INTO Task_Transp_Elements (id, id_task, id_head, summa, wgt, mest, mest_keg ,
                shirota, dolgota, quad, in_line,
                id_to, to_name, id_alloc_to, to_alloc_name, id_region, point)
                    Values (GEN_ID(GEN_Task_Transp_Elements_ID, 1), :id_task, :id, :summa, :wgt, :mest, :mest_keg,
                    :shirota, :dolgota, :quad, :in_line, :id_to, :to_name,
                                :id_alloc_to, :to_alloc_name, :id_region, :point);
            end
--Квадрат 3 слева направо -------------------------------------------------------------------------------
 FOR Select h.id, h.summa, h.wgt, h.mest, h.mest_keg, agt.shirota, agt.dolgota, agt.quad, agt.in_line,
            h.id_to, h.to_name, h.id_alloc_to, h.to_alloc_name, a.parent as id_region, h.point
        From v_Headers h
                    Inner Join Alloc_Gps agt On h.id_alloc_to = agt.id_alloc
                    Inner Join Allocation a On a.id = agt.id_alloc
    Where h.id_from = :headquarters  and h.data BETWEEN :data1 and :data2
        and agt.quad = 3
                Order by agt.in_line, agt.dolgota
        --Order by agt.shirota DESC
            INTO  :id, :summa, :wgt, :mest, :mest_keg, :shirota, :dolgota, :quad, :in_line, :id_to, :to_name,
            :id_alloc_to, :to_alloc_name, :id_region, :point
            do
            begin
             Insert INTO Task_Transp_Elements (id, id_task, id_head, summa, wgt, mest, mest_keg ,
                shirota, dolgota, quad, in_line,
                id_to, to_name, id_alloc_to, to_alloc_name, id_region, point)
                    Values (GEN_ID(GEN_Task_Transp_Elements_ID, 1), :id_task, :id, :summa, :wgt, :mest, :mest_keg,
                    :shirota, :dolgota, :quad, :in_line, :id_to, :to_name,
                                :id_alloc_to, :to_alloc_name, :id_region, :point);
            end
--Квадрат 4 слева направо -------------------------------------------------------------------------------
 FOR Select h.id, h.summa, h.wgt, h.mest, h.mest_keg, agt.shirota, agt.dolgota, agt.quad, agt.in_line,
            h.id_to, h.to_name, h.id_alloc_to, h.to_alloc_name, a.parent as id_region, h.point
        From v_Headers h
                    Inner Join Alloc_Gps agt On h.id_alloc_to = agt.id_alloc
                    Inner Join Allocation a On a.id = agt.id_alloc
    Where h.id_from = :headquarters  and h.data BETWEEN :data1 and :data2
        and agt.quad = 4
        Order by agt.in_line, agt.dolgota
        --Order by agt.shirota DESC
            INTO  :id, :summa, :wgt, :mest, :mest_keg, :shirota, :dolgota, :quad, :in_line, :id_to, :to_name,
            :id_alloc_to, :to_alloc_name, :id_region, :point
            do
            begin
             Insert INTO Task_Transp_Elements (id, id_task, id_head, summa, wgt, mest, mest_keg ,
                shirota, dolgota, quad, in_line,
                id_to, to_name, id_alloc_to, to_alloc_name, id_region, point)
                    Values (GEN_ID(GEN_Task_Transp_Elements_ID, 1), :id_task, :id, :summa, :wgt, :mest, :mest_keg,
                    :shirota, :dolgota, :quad, :in_line, :id_to, :to_name,
                                :id_alloc_to, :to_alloc_name, :id_region, :point);
            end
--END Заполнили Квадраты -------------------------------------------------------------------------------

--Select Sum(te.wgt) as wgt From Task_Transp_Elements te Where quad = 1 INTO :Q1_Wgt;
--Select Sum(te.wgt) as wgt From Task_Transp_Elements te Where quad = 2 INTO :Q2_Wgt;
--Select Sum(te.wgt) as wgt From Task_Transp_Elements te Where quad = 3 INTO :Q3_Wgt;
--Select Sum(te.wgt) as wgt From Task_Transp_Elements te Where quad = 4 INTO :Q4_Wgt;

Update  task_transp_elements Set circle = (Select Result
    From p_distance_gps(:head_shirota, :head_dolgota, shirota, dolgota)) Where  id_task = :id_task;

if ((:cnt <=0) and (auto_select_vh =1)) then
 begin
  --execute procedure p_auto_select_vh(:id_task);
 end

/*$$IBEC$$ Select Max(circle) From Task_Transp_Elements te Where  te.id_task = :id_task INTO :MAX_DISTANCE;
FOR Select te.id, te.circle From Task_Transp_Elements te Where id_task = :id_task  INTO :id, :circle DO
   begin
      if (circle <= :MAX_DISTANCE/2) then
        begin
            Update  task_transp_elements te
            Set circle = 1
             Where  te.id = :id;
        end
      else
        begin
            Update  task_transp_elements te
            Set circle = 2
             Where  te.id = :id;
        end
   end
 $$IBEC$$*/

Select Sum(wgt) as vsego_wgt From Task_Transp_Elements INTO :vsego_objects_wgt;
Select Sum(load_kg) as vsego_kg From
    Vehicle v Inner Join Vehicle_Online vo On v.id = vo.id_vehicle
        WHERE data = :data2
        INTO :vsego_vehicle_wgt;
cnt = 1; xodka = 1; xodka_limit = 2;
WHILE (cnt > 0) DO
  Begin
    if (:first_load_keg > 0) then xodka_str = cast(:xodka as varchar(5)) || 'keg';
    if (:first_load_keg = 0) then xodka_str = cast(:xodka as varchar(5)) || 'fas';
    FOR Select v.id, v.load_kg, v.speed,
        SUM(COALESCE(te.time_on,0.00)) as time_on From
        Vehicle v Inner Join Vehicle_Online vo On v.id = vo.id_vehicle
                   Left Join
                   (Select te.id_vh, te.distance, te.time_on From Task_Transp_Elements te
                    Inner Join Task_Transportation t On te.id_task = t.id
                     Where  t.id = :id_task and te.id_head <> -1) as te
                     On v.id = te.id_vh
                   WHERE vo.id_task = :id_task
                   Group by v.id, v.load_kg, v.speed
            Order by v.load_kg DESC --, SUM(COALESCE(te.distance,0.00))
        INTO :id_vh, :vehicle_wgt, :speed,  :vsego_time_on DO
     begin
     full_load = 0;
     lat1 = :head_shirota; -- Сюда координаты точки старта
     long1 = :head_dolgota;
     lat2 = null;
     long2 = null;
     vsego_distance  = 0.00; distance  = 0.00; time_on = 0.00;
     vh_load_kg = :vehicle_wgt;
     vehicle_wgt = :vehicle_wgt + :over_load_vh;
             FOR Select  te.id, te.wgt, te.shirota, te.dolgota, te.id_region, te.quad, te.circle From Task_Transp_Elements te
                        Inner Join Task_Transportation t On te.id_task = t.id
                     Where id_vh is null and t.id = :id_task and te.id_head <> -1 and mest_keg >= :first_load_keg
                        Order by te.id,te.quad
                        --Order by quad,te.shirota+te.dolgota DESC
                          --Order by te.quad, te.circle
                    INTO :id, :wgt, :lat2, :long2, :id_region, :quad, :circle
                 do
                 begin
                    get_on_board = 0;
                  --Считаем расстояние которое пройдет машина при перевозке этого груза
                    if (lat1 is null) then
                        begin
                         lat1 = :lat2;
                         long1 = :long2;
                        end
                    else
                        begin
                         if ((:lat1 <> :lat2) and (:long1 <> :long2)) then
                           begin
                             Select Result From p_distance_gps(:lat1, :long1, :lat2, :long2)
                              INTO :distance;
                             lat1 = :lat2;
                             long1 = :long2;
                             time_on = (:distance/(:speed*1000))*60;
                           end
                         else
                          begin
                            distance = 0.00;
                            time_on = 0.00;
                          end
                        end
                        if (:vh_load_kg < 8000) then    
                         begin    
                            if ((:vehicle_wgt >= :wgt) and (:vsego_distance <= :distance_limit)
                                    and (:vsego_time_on < :time_on_limit)) then
                                begin
                                 FOR Select vc.quad From vehicle_condition vc
                                       Where vc.id_task = :id_task
                                        and vc.id_vh = :id_vh INTO :qq DO
                                    begin
                                         Select vc.circle_start*1000 as circle_start, vc.circle_end*1000 as circle_end From vehicle_condition vc
                                           Where vc.id_task = :id_task and vc.id_vh = :id_vh and quad = :qq
                                            INTO :circle_start, :circle_end;
                                     if  (:quad = :qq and :circle Between :circle_start and :circle_end) then
                                        begin
                                            Update Task_Transp_Elements Set id_vh = :id_vh,
                                                distance = :distance , time_on = :time_on,
                                                xodka = :xodka_str
                                                Where id = :id;
                                                    vehicle_wgt = :vehicle_wgt - :wgt;
                                                    vsego_distance = :vsego_distance + :distance;
                                                    vsego_time_on = :vsego_time_on + :time_on;
                                        end
                                    end
                                end
                         end
                         else ---Более грузоподъемные
                         begin
                            if ((:vehicle_wgt >= :wgt) and (:xodka < 2) and
                                 (:vsego_time_on < :time_on_limit)) then
                                begin
                                    Update Task_Transp_Elements Set id_vh = :id_vh,
                                    distance = :distance, time_on = :time_on,
                                        xodka = :xodka_str
                                        Where id = :id;
                                            vehicle_wgt = :vehicle_wgt - :wgt;
                                            --vsego_distance = :vsego_distance + :distance;
                                end
                            else
                                begin
                                   vsego_distance = :vsego_distance - :distance;
                                   vsego_time_on  = :vsego_time_on  - :time_on;
                                end
                         end    
                 end
     --Проставим точку возврата на базу
         if (:vsego_distance > 0) then
          begin
          Select shirota, dolgota From Task_Transp_Elements Where id_task = :id_task and id_vh = :id_vh and xodka = :xodka_str
            Order by ord Desc Rows 1
            INTO :lat2, :long2;
          Select Result From p_distance_gps(:lat2, :long2, :head_shirota, :head_dolgota)
                              INTO :distance;
              Insert INTO Task_Transp_Elements (id, id_task, id_head, id_vh, xodka, summa, wgt, mest, mest_keg ,shirota, dolgota,
                                id_to, to_name, id_alloc_to, to_alloc_name, distance, time_on, ord)
                        Values (GEN_ID(GEN_Task_Transp_Elements_ID, 1), :id_task, -1, :id_vh, :xodka_str, 0, 0, 0, 0, :head_shirota, :head_dolgota, :headquarters, 'End_Base',
                                 null, null, :distance, 0, 999);
          end

     end
    --Проверка на нераспределенный груз
    Select Count(id) From Task_Transp_Elements Where id_vh is null and mest_keg >= :first_load_keg INTO :cnt;
    xodka = :xodka + 1;
    if ((xodka > :xodka_limit) and (:first_load_keg = 0)) then
     begin
        break;
     end
    else if ((cnt = 0) and (:first_load_keg >= 1)) then
     begin
        first_load_keg = 0;
        Select Count(id) From Task_Transp_Elements Where id_vh is null and mest_keg >= :first_load_keg INTO :cnt;
        xodka = 1;
     end
    else if ((cnt <> 0) and (:first_load_keg >= 1) and (xodka > :xodka_limit)) then
     begin
        first_load_keg = 0;
        Select Count(id) From Task_Transp_Elements Where id_vh is null and mest_keg >= :first_load_keg INTO :cnt;
        xodka = 1;
     end
  end

Update  task_transp_elements Set id_vh = -1 Where id_vh is null;
i = 1;
While (i<=4) DO
begin
Update  task_transp_elements
    Set d_dolgota =dolgota - (Select Min(dolgota) From Task_Transp_Elements Where quad= :i and id_task = :id_task),
    d_shirota =shirota - (Select Min(shirota) From Task_Transp_Elements Where quad= :i and id_task = :id_task)
  Where id_task = :id_task  and quad= :i;
  i = :i + 1;
end
Update task_transp_elements Set d_dolgota = d_dolgota*-1  Where quad = 2 and id_task = :id_task;
Update task_transp_elements Set d_dolgota = d_dolgota*-1, d_shirota = d_shirota*-1 Where quad = 3 and id_task = :id_task;
Update task_transp_elements Set d_shirota = d_shirota*-1 Where quad = 4 and id_task = :id_task;
--Select Min(dolgota) From task_transp_elements
end^

SET TERM ; ^


SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_import_orders (
    id_cus BIGINT NOT NULL,
    data DATE)
AS
DECLARE VARIABLE  ID             BIGINT;
DECLARE VARIABLE  ID_CLI         BIGINT;
DECLARE VARIABLE  ID_OBJ         BIGINT;
DECLARE VARIABLE  ID_ALLOC_FROM  BIGINT;
DECLARE VARIABLE  ID_ALLOC_TO    BIGINT;
DECLARE VARIABLE  ID_ALLOC_GPS   BIGINT;
DECLARE VARIABLE  ID_OBJ_CROSS VARCHAR(25);
DECLARE VARIABLE  ID_HEAD   BIGINT;
DECLARE VARIABLE  ID_HEAD_CROSS VARCHAR(45);
DECLARE VARIABLE  ID_CROSS  VARCHAR(25);
DECLARE VARIABLE  ID_CUS_CROSS  VARCHAR(25);
DECLARE VARIABLE  NAME_CUS  VARCHAR(75);
DECLARE VARIABLE  POINT  VARCHAR(75);
DECLARE VARIABLE  ID_CH     VARCHAR(25);
DECLARE VARIABLE  NAME      VARCHAR(75);
DECLARE VARIABLE  CHARACT   VARCHAR(75);
DECLARE VARIABLE  EDIZM     VARCHAR(25);
DECLARE VARIABLE  ID_EDIZM  BIGINT;
DECLARE VARIABLE  KF        NUMERIC(10,2);
DECLARE VARIABLE  WGT        NUMERIC(10,2);
DECLARE VARIABLE  QTY        NUMERIC(10,2);
DECLARE VARIABLE  QTY_M        NUMERIC(10,2);
DECLARE VARIABLE  PRICE        NUMERIC(10,2);
DECLARE VARIABLE  CMT       VARCHAR(75);
DECLARE VARIABLE shirota DOUBLE PRECISION;
DECLARE VARIABLE dolgota DOUBLE PRECISION;
DECLARE VARIABLE shirota1 DOUBLE PRECISION;
DECLARE VARIABLE dolgota1 DOUBLE PRECISION;


begin
-- Удалим если есть предыдущие за эту дату
Delete From Elements e Where
    Exists (Select h.id From Headers h Where h.data = :data and h.id = e.id_head
    and Exists (Select id From Headers_Cross Where id_head = h.id and id_cus = :id_cus));
Delete From Headers h Where h.data = :data
    and Exists (Select id From Headers_Cross Where id_head = h.id and id_cus = :id_cus);
Delete From Headers_Cross hc Where
    not Exists (Select id From Headers Where id = hc.id_head);

    SELECT ID From Allocation Where id_cus = :id_cus ROWS 1 INTO :id_alloc_from;
    FOR SELECT  ID_OBJ, NAME_OBJ, ID_CH, CHARACT, EDIZM, KF, WGT From Import_Orders
            INTO  :id_obj_cross, :name, :id_ch, :charact, :edizm, :kf, :wgt
            do
            begin
               id_obj = null;
               SELECT oc.id_obj From Objects_CROSS oc
                Where oc.id_obj_cross = (TRIM(:id_obj_cross)||TRIM(COALESCE(:id_ch,' ')))
                    and oc.id_cus = :id_cus
                    INTO :id_obj;
                    if (:id_obj is null) then  -- Не нашли в базе - заводим новый
                     begin
                        id_obj = GEN_ID(GEN_Objects_ID, 1);
                        Insert INTO Objects (id, name, id_cat)
                            Values (:id_obj, TRIM(:name) || ' ' || TRIM(COALESCE(:charact,'')), 20000000018);
                        Insert INTO Ed_Izm (id, id_obj, name, wgt, cpc, kf, vid)
                            Values (GEN_ID(GEN_ED_IZM_ID, 1),:id_obj, :edizm, :wgt, 1, :kf, 1);
                        Insert INTO Objects_Cross (id, id_obj, id_cus, id_obj_cross)
                            Values (GEN_ID(GEN_Objects_CROSS_ID, 1), :id_obj, :id_cus, TRIM(:id_obj_cross)||TRIM(COALESCE(:id_ch,'')));
                     end

            end
    FOR SELECT Distinct id, id_cus, data, cmt, shirota, dolgota, NAME_CUS, POINT From Import_Orders
        INTO :id_head_cross, :id_cus_cross, :data, :cmt, :shirota, :dolgota, :NAME_CUS, :POINT
     do
     begin
            id_alloc_to = null;
            shirota1 = null;
            dolgota1 = null;
            ID_ALLOC_GPS = null;
            SELECT id From Allocation
                Where id_cus = (Select id_cus From Customers_cross Where id_cus_cross = :id_cus_cross Rows 1)
                INTO :id_alloc_to;
            if (:id_alloc_to is null) then  -- Не нашли в базе - заводим новый
             begin
                id_cli = GEN_ID(GEN_Customers_ID, 1);
                Insert INTO Customers (id, name, fiz_address)
                    Values (:id_cli, :NAME_CUS, :POINT);
                Insert INTO Customers_Cross (id, id_cus, id_cus_cross)
                    Values (GEN_ID(GEN_Customers_CROSS_ID, 1), :id_cli, TRIM(:id_cus_cross));
                SELECT id From Allocation Where id_cus = :id_cli INTO :id_alloc_to;
                    if (:shirota = 0) then shirota = null;
                    if (:dolgota = 0) then dolgota = null;
                    INSERT INTO alloc_gps (id, id_alloc, shirota, dolgota)
                        VALUES (GEN_ID(GEN_ALLOC_GPS_ID, 1), :id_alloc_to, :shirota, :dolgota);
             end
            else
             begin
                 Select id_cus From Allocation Where id = :id_alloc_to INTO :id_cli;
                    Update Customers Set fiz_address = :point
                        Where id = :id_cli;
                SELECT id, COALESCE(shirota, 0), COALESCE(dolgota, 0) From Alloc_Gps Where id_alloc = :id_alloc_to ROWS 1 INTO :ID_ALLOC_GPS, :shirota1, :dolgota1;
                if (:ID_ALLOC_GPS is null) then
                 begin
                    INSERT INTO alloc_gps (id, id_alloc, shirota, dolgota)
                        VALUES (GEN_ID(GEN_ALLOC_GPS_ID, 1), :id_alloc_to, :shirota, :dolgota);
                 end
                else
                 begin
                  if ((:shirota1 <> :shirota) or (:dolgota1 <> :dolgota))  then
                   begin
                    if ((:shirota <> 0) and (:dolgota <> 0)) then
                     begin
                        Update alloc_gps Set shirota = :shirota, dolgota = :dolgota, time_stamp = current_timestamp
                            Where id = :ID_ALLOC_GPS;
                     end
                   end
                 end
             end
            id_head = GEN_ID(GEN_Headers_ID, 1);
            FOR SELECT ID_OBJ, ID_CH, KF, QTY, QTY_M, PRICE
                From Import_Orders WHERE id = :id_head_cross
             INTO :id_obj_cross, :id_ch, :kf, :qty, :qty_m, :price
             do
             begin
              SELECT oc.id_obj From Objects_CROSS oc
                Where oc.id_obj_cross = (TRIM(:id_obj_cross)||TRIM(COALESCE(:id_ch,' ')))
                    and oc.id_cus = :id_cus
                    INTO :id_obj;
              SELECT id From Ed_Izm Where id_obj = :id_obj and kf = :kf INTO :id_edizm;
              INSERT INTO Elements (ID, ID_OBJ, AMOUNT, ID_EDIZM, PRICE, ID_HEAD,
                  ID_PRICE, ID_CURR)
                VALUES (GEN_ID(GEN_Elements_ID, 1), :id_obj, :qty, :id_edizm, :price, :id_head, null, null);
             end
            INSERT INTO Headers (ID, ID_ALLOC_FROM, ID_ALLOC_TO, ID_TYPE, DATA)
                VALUES (:id_head, :id_alloc_from, :id_alloc_to, 20000000002, :data);
            INSERT INTO Head_Slices (ID, ID_HEAD, ID_SLICE)
                VALUES (GEN_ID(GEN_Head_Slices_ID, 1), :id_head, 20000000005);
            INSERT INTO Headers_Cross (ID, ID_HEAD, ID_CUS, ID_HEAD_CROSS)
                VALUES (GEN_ID(GEN_Headers_CROSS_ID, 1), :id_head, :id_cus, :id_head_cross);
     end
     Delete From alloc_gps Where shirota = dolgota;
     execute procedure p_div_on_quad(0);

end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_import_gps
AS
--DECLARE VARIABLE data DATE;
DECLARE VARIABLE  ID_CUS        BIGINT;
DECLARE VARIABLE  ID_ALLOC      BIGINT;
DECLARE VARIABLE  ID_CROSS      VARCHAR(25);
DECLARE VARIABLE  SHIROTA       NUMERIC(16,13);
DECLARE VARIABLE  DOLGOTA       NUMERIC(16,13);
begin
  FOR SELECT      ID_CROSS, SHIROTA, DOLGOTA
        FROM Import_Gps g
               INTO :id_cross, :shirota, :dolgota
              do
              begin
               id_cus = null;
               Select id_cus From Customers_Cross Where id_cus_cross = TRIM(:id_cross) ROWS 1
                 INTO :id_cus;
               if (:id_cus is not null) then
                begin
                   Select id From Allocation Where id_cus = :id_cus
                     INTO :id_alloc;
                   INSERT INTO alloc_gps (id, id_alloc, shirota, dolgota)
                        VALUES (GEN_ID(GEN_ALLOC_GPS_ID, 1), :id_alloc, :shirota, :dolgota);
                end

              end
end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_import_cus
AS
--DECLARE VARIABLE data DATE;
DECLARE VARIABLE  ID        BIGINT;
DECLARE VARIABLE  ID_CUS    BIGINT;
DECLARE VARIABLE  ID_CROSS  VARCHAR(25);
DECLARE VARIABLE  INN       VARCHAR(15);
DECLARE VARIABLE  EGRPOU    VARCHAR(75);
DECLARE VARIABLE  NAME      VARCHAR(75);
DECLARE VARIABLE  NAME_FULL VARCHAR(200);
DECLARE VARIABLE  SVID_NDS  VARCHAR(15);
DECLARE VARIABLE  MANAGER   VARCHAR(35);

begin
  FOR SELECT     ID, ID_CROSS, NAME, NAME_FULL, INN, EGRPOU, SVID_NDS, MANAGER
        FROM Import_Customers c
               INTO :id, :id_cross, :name, :name_full, :inn, :egrpou, :svid_nds, :manager
              do
              begin
                id_cus = GEN_ID(GEN_Customers_ID, 1);
                Insert INTO Customers (id, name, name_full, inn, egrpou, svid_nds)
                    Values (:id_cus, Replace(TRIM(:name), '?', 'i'), Replace(:name_full, '?', 'i'), :inn, :egrpou, :svid_nds);
                Insert INTO Customers_Cross (id, id_cus, id_cus_cross)
                    Values (GEN_ID(GEN_Customers_CROSS_ID, 1), :id_cus, TRIM(:id_cross));
              end
end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_import_obj (
    id_cus BIGINT NOT NULL)
AS
--DECLARE VARIABLE data DATE;
DECLARE VARIABLE  ID        BIGINT;
DECLARE VARIABLE  ID_OBJ    BIGINT;
DECLARE VARIABLE  ID_CROSS  VARCHAR(25);
DECLARE VARIABLE  ID_CH     VARCHAR(25);
DECLARE VARIABLE  NAME      VARCHAR(75);
DECLARE VARIABLE  CHARACT   VARCHAR(75);
DECLARE VARIABLE  EDIZM     VARCHAR(25);
DECLARE VARIABLE  KF        NUMERIC(10,2);
DECLARE VARIABLE  WGT       NUMERIC(10,2);
DECLARE VARIABLE  CPC       NUMERIC(10,2);
DECLARE VARIABLE  TMP_WGT   NUMERIC(10,2);
DECLARE VARIABLE  TMP_CPC   NUMERIC(10,2);

begin
  FOR SELECT     ID, ID_CROSS, NAME, ID_CH, CHARACT, EDIZM, KF, WGT, CPC
        FROM Import_objects i
               INTO :id, :id_cross, :name, :id_ch, :charact, :edizm,
               :kf, :wgt, :cpc
              do
              begin
                id_obj = GEN_ID(GEN_Objects_ID, 1);
                Insert INTO Objects (id, name, id_cat)
                    Values (:id_obj, TRIM(:name) || ' ' || TRIM(COALESCE(:charact,'')), 20000000018);
                if (:kf is not null) then
                    begin
                        tmp_wgt = COALESCE(:wgt, 0)/:kf;
                        tmp_cpc = COALESCE(:cpc, 0)/:kf;
                    end
                Insert INTO Ed_Izm (id, id_obj, name, wgt, cpc, kf, vid)
                    Values (GEN_ID(GEN_ED_IZM_ID, 1),:id_obj, 'шт.', :tmp_wgt, :tmp_cpc, 1, 1);
                Insert INTO Ed_Izm (id, id_obj, name, wgt, cpc, kf, vid)
                    Values (GEN_ID(GEN_ED_IZM_ID, 1),:id_obj, :edizm, :wgt, :cpc, :kf, null);

                Insert INTO Objects_Cross (id, id_obj, id_cus, id_obj_cross)
                    Values (GEN_ID(GEN_Objects_CROSS_ID, 1), :id_obj, :id_cus, TRIM(:id_cross)||TRIM(:id_ch));
              end
end^

SET TERM ; ^

SET TERM ^ ;
CREATE OR ALTER PROCEDURE p_cut_id
AS --В Списке клиентов в скобках указан код клиента(Энтрада) Вырезаем его оттуда 
declare variable name varchar(100);
declare variable s_id  VARCHAR(15);
declare variable id integer;
declare variable p1 integer;
declare variable p2 integer;
begin
     FOR SELECT g.id, g.name
        FROM import_gps g
               INTO :id, :name
               do
                begin
                  p1 = POSITION('(', :name);
                  p2 = POSITION(')', :name);
                  IF (:p2 - :p1 <= 0) THEN
                      s_id = SUBSTRING(:name FROM :p1+1 FOR 0);
                  ELSE
                      s_id = SUBSTRING(:name FROM :p1+1 FOR (:p2 - :p1) - 1);
                  Update import_gps Set id_cross = :s_id Where id = :id;
                end 

end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_move_obj (
    id_obj BIGINT NOT NULL,
    data_in DATE)
RETURNS (
    id_e BIGINT,
    d1 DATE)
AS
DECLARE VARIABLE data DATE;
DECLARE VARIABLE  depth_out_party INTEGER;
begin
Select cast(vlv as INTEGER) From Properties Where name = 'depth_out_party'
    INTO :depth_out_party;
  FOR SELECT h.data
        FROM Elements e INNER JOIN Headers h ON e.id_head = h.id
             WHERE e.id_obj = :id_obj and h.data >= :data_in
                 Group by h.data
               INTO :data
  do
  begin
      FOR Select e.id, h.data From Elements e
                INNER JOIN Headers h ON e.id_head = h.id
                    WHERE e.id_obj = :id_obj and h.data = :data
                        Rows :depth_out_party
        INTO :id_e, :d1
      do
      suspend;
  end
end^

SET TERM ; ^

/* Following GRANT statetements are generated automatically */

GRANT SELECT ON PROPERTIES TO PROCEDURE P_MOVE_OBJ;
GRANT SELECT ON ELEMENTS TO PROCEDURE P_MOVE_OBJ;
GRANT SELECT ON HEADERS TO PROCEDURE P_MOVE_OBJ;

/* Existing privileges on this procedure */

GRANT EXECUTE ON PROCEDURE P_MOVE_OBJ TO SYSDBA;
SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_test (
    i INTEGER NOT NULL = 1000)
AS
BEGIN

        WHILE (i<>0) DO
        BEGIN
         Insert Into Elements (id, id_obj, amount, price, id_head)
            Values (GEN_ID(GEN_Elements_ID, 1), :i+20000000001, 1210.0000, 21.0000, 20000000001);
            i=:i-1;
        END
END^

SET TERM ; ^

/* Following GRANT statetements are generated automatically */

GRANT INSERT ON ELEMENTS TO PROCEDURE P_TEST;

/* Existing privileges on this procedure */

GRANT EXECUTE ON PROCEDURE P_TEST TO SYSDBA;




SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_test_objects (
    i INTEGER NOT NULL = 150000)
AS
BEGIN

        WHILE (i<>0) DO
        BEGIN
         Insert INTO Objects (id, name, id_cat)
             Values (GEN_ID(GEN_Objects_ID, 1), 'Объект книга №' || CAST(:i as varchar(10)),
                 20000000002);
            i=:i-1;
        END
END^

SET TERM ; ^

/* Following GRANT statetements are generated automatically */

GRANT INSERT ON OBJECTS TO PROCEDURE P_TEST_OBJECTS;

/* Existing privileges on this procedure */

GRANT EXECUTE ON PROCEDURE P_TEST_OBJECTS TO SYSDBA;

SET TERM ^ ;

ALTER PROCEDURE P_FILL_BASE
AS
begin

Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'depth_out_party', '20', 'Глубина анализа партий по одному объекту за один день(при увеличении - снижает производительность!)');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'prime_cost', null, 'Тип цен себестоимости, если null - будет взята входная цена.');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'headquarters', '20000000004', 'Головная организация');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'PRICE_FOR_TYPE1', '20000000007', 'Колонка цены_1 в браузере объектов. После изменения обновить словарь данных для правильного отображения заголовков столбцов');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'PRICE_FOR_TYPE2', '20000000008', 'Колонка цены_2 в браузере объектов');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'PRICE_FOR_TYPE3', '20000000009', 'Колонка цены_3 в браузере объектов');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'PRICE_FOR_TYPE4', '20000000010', 'Колонка цены_4 в браузере объектов');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'PRICE_FOR_TYPE5', '20000000011', 'Колонка цены_5 в браузере объектов');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'default_price', '20000000008', 'Цена по умолчанию');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'default_currency', '20000000013', 'Валюта по умолчанию');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'sprav_currency', '20000000012', 'Справочник валют');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'sprav_price', '20000000006', 'Справочник цен');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'distance_limit', '9999999', 'Лимит в метрах по одной машине за одну ходку');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'time_on_limit', '9999999', 'Лимит времени(минут) по одной машине за все ходки');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'time_on_unload', '0', 'Лимит времени на разгрузку для одной точки');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'auto_select_vh', '0', 'Автоматический подбор машин на рейс');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'kegi_singl', '0', 'Кеги везти отдельно');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'over_load_vh', '0', 'Перегрузка машин');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'limit_point_vh', '45', 'Лимит точек на машину');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'depth_ord_logistik', '11', 'Глубина расчета порядка объезда точек для логистики - не более 16');
Insert Into Properties (id, name, vlv, comment)
    Values (GEN_ID(GEN_Properties_ID, 1), 'version', '&alpha;Cassiopeia', 'Версия базы');
    
    
    

Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Категории объектов', null); --ID = 20000000001
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Книги', 20000000001);
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Молочка', 20000000001);
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Водостоки', 20000000001);
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Оборудование', 20000000001);

Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Типы цен', null); --ID = 20000000006
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Учетная', 20000000006);
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Оптовая', 20000000006);
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Розничная', 20000000006);
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Мелкий опт.', 20000000006);
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Опт_Амстор.', 20000000006);
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Валюты', null); --ID = 20000000012
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'UAH', 20000000012);
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'USD', 20000000012);

Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Категории клиентов', null);--ID = 20000000015
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Поставщики', 20000000015);
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Покупатели', 20000000015);
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'Импорт_Энтрада', 20000000001); --ID = 20000000018
Insert INTO Sprav (id, name, parent)
    Values (GEN_ID(GEN_Sprav_ID, 1),'EUR', 20000000012); --ID = 20000000019
    
Insert INTO COLORS (id, c_r, c_e, c_h)
    Values ( 1, 'красный', 'red', 'ff0000');
Insert INTO COLORS (id, c_r, c_e, c_h)
    Values ( 2, 'оранжевый', 'orange', 'ffa500');
Insert INTO COLORS (id, c_r, c_e, c_h)
    Values ( 3, 'желтый', 'yellow', 'ffff00');
Insert INTO COLORS (id, c_r, c_e, c_h)
    Values ( 4, 'зеленый', 'green', '00ff00');
Insert INTO COLORS (id, c_r, c_e, c_h)
    Values ( 5, 'голубой', 'blue', '42aaff');
Insert INTO COLORS (id, c_r, c_e, c_h)
    Values ( 6, 'синий', 'darkblue', '0000ff');
Insert INTO COLORS (id, c_r, c_e, c_h)
    Values ( 7, 'фиолетовый', 'violet', '8b00ff');
    
   

Insert INTO Slices (id, name, name_long)
    Values (GEN_ID(GEN_Slices_ID, 1),'Бух.', 'Бухгалтерский учет');
Insert INTO Slices (id, name, name_long)
    Values (GEN_ID(GEN_Slices_ID, 1),'Упр.', 'Управленческий учет');
Insert INTO Slices (id, name, name_long)
    Values (GEN_ID(GEN_Slices_ID, 1),'План', 'Плановый учет');
Insert INTO Slices (id, name, name_long)
    Values (GEN_ID(GEN_Slices_ID, 1),'Факт', 'Фактический учет');
Insert INTO Slices (id, name, name_long)
    Values (GEN_ID(GEN_Slices_ID, 1),'Черновик', 'Черновик');


Insert INTO HeadTypes (id, name, sname)
    Values (GEN_ID(GEN_HEADTYPES_ID, 1),'Поступление товаров', 'ПТ');
Insert INTO HeadTypes (id, name, sname)
    Values (GEN_ID(GEN_HEADTYPES_ID, 1),'Реализация товаров', 'PТ');
Insert INTO HeadTypes (id, name, sname)
    Values (GEN_ID(GEN_HEADTYPES_ID, 1),'Расходный кассовый ордер', 'PKO');
    
    
Insert INTO HeadTypes_DESTINATION (id, id_headquarters, id_from_type, id_to_type)
    Values (GEN_ID(GEN_HEADTYPES_DESTINATION_ID, 1), (Select cast(vlv as bigint) as vlv From Properties Where name='headquarters'), null, 20000000001);
Insert INTO HeadTypes_DESTINATION (id, id_headquarters, id_from_type, id_to_type)
    Values (GEN_ID(GEN_HEADTYPES_DESTINATION_ID, 1), (Select cast(vlv as bigint) as vlv From Properties Where name='headquarters'), 20000000002, null);
Insert INTO HeadTypes_DESTINATION (id, id_headquarters, id_from_type, id_to_type)
    Values (GEN_ID(GEN_HEADTYPES_DESTINATION_ID, 1), (Select cast(vlv as bigint) as vlv From Properties Where name='headquarters'), 20000000003, null);

Insert INTO Head_Slices (id, id_head, id_slice)
    Values (GEN_ID(GEN_HEAD_Slices_ID, 1),20000000002, 20000000002);

/* Insert INTO Allocation (id, name, id_cus, parent)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Склад Васи', 20000000001, 20000000005);
Insert INTO Allocation (id, name, id_cus, parent)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Склад Пети', 20000000002, 20000000005);
Insert INTO Allocation (id, name, id_cus, parent)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Склад Феди', 20000000003, 20000000005); */
Insert INTO Allocation (id, name, parent)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Европа', null);
Insert INTO Allocation (id, name, parent)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Украина', 20000000001);
Insert INTO Allocation (id, name, parent)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Донецкая область', 20000000002);
Insert INTO Allocation (id, name, parent)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Макеевка', 20000000003);--20000000004
Insert INTO Allocation (id, name, parent)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Донецк', 20000000003);--20000000005
    
Insert INTO Allocation (id, name, parent)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Крым', 20000000002);--20000000006

    /* Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Куйбышевский р-он', 20000000005, 1); --20000000006
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Киевский р-он', 20000000005, 3); --20000000007
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Ворошиловский р-он', 20000000005, 4); --20000000008
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Ленинский р-он', 20000000005, 2); --20000000009
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Кировский р-он', 20000000005, 5); --20000000010
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Петровский р-он', 20000000005, 6); --20000000011
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Пролетарский р-он', 20000000005, 7); --20000000012
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Калининский р-он', 20000000005, 8); --20000000013
    
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Советский р-он', 20000000004, 1); --20000000014
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Червоногвардейский р-он', 20000000004, 4); --20000000015
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Горняцкий р-он', 20000000004, 2); --20000000016
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Центрально-городской р-он', 20000000004, 3); --20000000017
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Кировский мк р-он', 20000000004, 5); --20000000018

Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Волновахский р-он', 20000000003, 1); --20000000019
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Новоселовский р-он', 20000000003, 2); --20000000020
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Красноармейский р-он', 20000000003, 4); --20000000021
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Марьинский р-он', 20000000003, 3); --20000000022
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Ясиноватский р-он', 20000000003, 5); --20000000023
Insert INTO Allocation (id, name, parent, ord)
    Values (GEN_ID(GEN_Allocation_ID, 1),'Старобешевский р-он', 20000000003, 6); --20000000024 */

    
 Insert INTO Customers (id, name, id_cat, u_f)
    Values (GEN_ID(GEN_Customers_ID, 1),'Вася', 20000000016, 'Юр. лицо');
Insert INTO Customers (id, name, id_cat, u_f)
    Values (GEN_ID(GEN_Customers_ID, 1),'Петя', null, 'Физ. лицо');
Insert INTO Customers (id, name, id_cat, u_f)
    Values (GEN_ID(GEN_Customers_ID, 1),'Федя', 20000000017, 'Юр. лицо');
Insert INTO Customers (id, name, id_cat, u_f)
    Values (GEN_ID(GEN_Customers_ID, 1),'Импорт БД ЭНТРАДА', null, null);


--Insert INTO ALLOC_GPS (id, id_alloc, shirota, dolgota) --Феодосия
--    Values (GEN_ID(GEN_ALLOC_GPS_ID, 1), 20000000010, 45.069914, 35.388398);
Insert INTO ALLOC_GPS (id, id_alloc, shirota, dolgota) --Донецк
    Values (GEN_ID(GEN_ALLOC_GPS_ID, 1), 20000000010, 48.024616, 37.762340);

    
--Если не задан вид учета, тогда схема проводок для всех учетов
Insert INTO DualRec (id, dt, kt, fld_name, id_head_type)
    Values (GEN_ID(GEN_DualRec_ID, 1), 281, 631, 'e.summa', 20000000001);
Insert INTO DualRec (id, dt, kt, fld_name, id_head_type)
    Values (GEN_ID(GEN_DualRec_ID, 1), 361, 702, 'e.summa', 20000000002);
Insert INTO DualRec (id, dt, kt, fld_name, id_head_type)
    Values (GEN_ID(GEN_DualRec_ID, 1), 702, 641, 'e.summa*e.nds', 20000000002);
Insert INTO DualRec (id, dt, kt, fld_name, id_head_type)
    Values (GEN_ID(GEN_DualRec_ID, 1), 702, 791, 'e.summa-e.summa*e.nds', 20000000002);
Insert INTO DualRec (id, dt, kt, fld_name, id_head_type)
    Values (GEN_ID(GEN_DualRec_ID, 1), 902, 281, 'e.summa', 20000000002);
Insert INTO DualRec (id, dt, kt, fld_name, id_head_type)
    Values (GEN_ID(GEN_DualRec_ID, 1), 791, 902, 'e.summa', 20000000002);

   
Insert INTO Ed_Izm (id, id_obj, name, kf, vid)
    Values (GEN_ID(GEN_Ed_Izm_ID, 1), 20000000001, 'шт.', 1, 1);
Insert INTO Ed_Izm (id, id_obj, name, kf, vid)
    Values (GEN_ID(GEN_Ed_Izm_ID, 1), 20000000001, 'пач14', 14, null);
Insert INTO Ed_Izm (id, id_obj, name, kf, vid)
    Values (GEN_ID(GEN_Ed_Izm_ID, 1), 20000000001, 'пач15', 15, null);
    
    
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Уильям Шекспир. Зимняя сказка(пер.Петр Петров)', 20000000002);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Сказки Пушкин', 20000000002);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Плавленка ТМ ШОСТКА', 20000000003);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Масло сливочное 82% Президент(Франция) 400г.', 20000000003);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Масло сливочное 82% Valio(Финляндия) 200г.', 20000000003);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Сливки животные 35,1% Президент(Франция)', 20000000003);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Творог 15% Творожная традиция 450г Творожная традиция', 20000000003);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Творог  0% Творожная традиция 450г', 20000000003);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Козье молоко 2,5% 0,31 Чистая Линия (Россия)', 20000000003);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Козье молоко 3,3% Чистая Линия (Россия)', 20000000003);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Можайское молоко 2,5% 450мл. (Россия)', 20000000003);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Гауда (ТМ Шостка) сыр 50%', 20000000003);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Королевский (ТМ Шостка) сыр 45%', 20000000003);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Шпилька с дюбелем L 100 мм (белая)', 20000000004);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Обойма трубы с винтом белая', 20000000004);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Голова экструдера с комплектом насадок (16,20,32)', 20000000005);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Клапан 4WE 10E3 X/CG24 N9 K4', 20000000005);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Клапан 7WE 10E3 X/CG24 N9 K4', 20000000005);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Миксер SHR50A', 20000000005);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Насос Vickers 3525V25А-17-1ВВ-22R1', 20000000005);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Термопара NR-31B', 20000000005);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Шнек HTF120xB-01-07J,S0120xBO', 20000000005);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Шнек S0090WBO (ТПА 0707009020222)', 20000000005);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Шнек S0090WBO (ТПА 0707009020231)', 20000000005);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Шнек S0090WBO (ТПА HTF 90W/JI 0707009020223)', 20000000005);
Insert INTO Objects (id, name, id_cat)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Шнек и гильза для переработки ПВХ (для ТПА HTF360Х', 20000000005);
Insert INTO Objects (id, name, id_cat, nds)
    Values (GEN_ID(GEN_Objects_ID, 1), 'Гильза для переработки ПВХ (для ТПА HTF370Х', 20000000005, null);
Insert INTO Objects (id, name, id_cat, nds)
    Values (GEN_ID(GEN_Objects_ID, 1), 'ПП для переработки ПВХ (для ТПА HTF67-Х', 20000000005, 0);

    
Insert INTO Currency (id, id_curr_from, id_curr_to, data, base, rate )
    Values (GEN_ID(GEN_CURRENCY_ID, 1), 20000000013, 20000000013, '01.01.2012', 1, 1.00);
Insert INTO Currency (id, id_curr_from, id_curr_to, data, base, rate )
    Values (GEN_ID(GEN_CURRENCY_ID, 1), 20000000014, 20000000013, '01.01.2012', 1, 8.00);
Insert INTO Currency (id, id_curr_from, id_curr_to, data, base, rate )
    Values (GEN_ID(GEN_CURRENCY_ID, 1), 20000000019, 20000000013, '01.01.2012', 1, 9.55);

Insert INTO Prices (id, id_type, id_obj, data, price, id_curr)
    Values (GEN_ID(GEN_PRICES_ID, 1), 20000000007, 20000000001, '01.01.2012', 3.45, 20000000013);
Insert INTO Prices (id, id_type, id_obj, data, price, id_curr)
    Values (GEN_ID(GEN_PRICES_ID, 1), 20000000008, 20000000001, '01.01.2012', 5.45, 20000000013);
Insert INTO Prices (id, id_type, id_obj, data, price, id_curr)
    Values (GEN_ID(GEN_PRICES_ID, 1), 20000000009, 20000000001, '01.01.2012', 7.45, 20000000013);
Insert INTO Prices (id, id_type, id_obj, data, price, id_curr)
    Values (GEN_ID(GEN_PRICES_ID, 1), 20000000010, 20000000001, '01.01.2012', 4.45, 20000000013);
Insert INTO Prices (id, id_type, id_obj, data, price, id_curr)
    Values (GEN_ID(GEN_PRICES_ID, 1), 20000000011, 20000000001, '01.01.2012', 6.45, 20000000013);

Insert INTO Element_Def (id, name, parent, isbase)
    Values (GEN_ID(Gen_Element_Def_ID, 1), 'Prices', null, 0);
Insert INTO Element_Def (id, name, parent, isbase)
    Values (GEN_ID(Gen_Element_Def_ID, 1), 'EdIzm', null, 0);
Insert INTO Element_Def (id, name,parent,isbase)
    Values (GEN_ID(Gen_Element_Def_ID, 1), 'Currency', null, 0);
Insert INTO Element_Def (id, name,parent,isbase)
    Values (GEN_ID(Gen_Element_Def_ID, 1), 'Nds', null, 0);


Insert INTO Element_Def (id, name, parent, isbase)
    Values (GEN_ID(Gen_Element_Def_ID, 1), 'Оптовая', 20000000001 , 1);     --Prices (5)
Insert INTO Element_Def (id, name, parent, isbase)
    Values (GEN_ID(Gen_Element_Def_ID, 1), 'Розничная', 20000000001 , 0);     --Prices (6)
Insert INTO Element_Def (id, name, parent, isbase)
    Values (GEN_ID(Gen_Element_Def_ID, 1), 'Учетная', 20000000001 , 0);        --Prices (7)
Insert INTO Element_Def (id, name, parent, isbase)
    Values (GEN_ID(Gen_Element_Def_ID, 1), 'шт', 20000000002 , 1);        --EdIzm (8)
Insert INTO Element_Def (id, name, parent, isbase)
    Values (GEN_ID(Gen_Element_Def_ID, 1), 'кг', 20000000002 , 0);        --EdIzm (9)
Insert INTO Element_Def (id, name, parent, isbase)
    Values (GEN_ID(Gen_Element_Def_ID, 1), 'UAH', 20000000003 , 1);        --Currency (10)
Insert INTO Element_Def (id, name, parent, isbase)
    Values (GEN_ID(Gen_Element_Def_ID, 1), 'USD', 20000000003 , 0);        --Currency (11)
Insert INTO Element_Def (id, name, parent, isbase)
    Values (GEN_ID(Gen_Element_Def_ID, 1), 'nds20', 20000000004 , 1);        --Nds (12)
Insert INTO Element_Def (id, name, parent, isbase)
    Values (GEN_ID(Gen_Element_Def_ID, 1), 'nds0', 20000000004 , 0);        --Nds (13)
     
Insert INTO Element_Def_Values (id, id_ed, id_obj, vlv, data)
    Values (GEN_ID(Gen_Element_Def_Values_ID, 1), 20000000005, 20000000001, 3.50, '2011-01-01');
Insert INTO Element_Def_Values (id, id_ed, id_obj, vlv, data)
    Values (GEN_ID(Gen_Element_Def_Values_ID, 1), 20000000007, 20000000001, 2.50, '2011-01-01');
Insert INTO Element_Def_Values (id, id_ed, id_obj, vlv, data)
    Values (GEN_ID(Gen_Element_Def_Values_ID, 1), 20000000008, 20000000001, 1, '2011-01-01');
Insert INTO Element_Def_Values (id, id_ed, id_obj, vlv, data)
    Values (GEN_ID(Gen_Element_Def_Values_ID, 1), 20000000010, null, 1, '2011-01-01');
Insert INTO Element_Def_Values (id, id_ed, id_obj, vlv, data)
    Values (GEN_ID(Gen_Element_Def_Values_ID, 1), 20000000011, null, 8, '2011-01-01');
Insert INTO Element_Def_Values (id, id_ed, id_obj, vlv, data)
    Values (GEN_ID(Gen_Element_Def_Values_ID, 1), 20000000012, null, 0.2, '2011-01-01');
Insert INTO Element_Def_Values (id, id_ed, id_obj, vlv, data)
    Values (GEN_ID(Gen_Element_Def_Values_ID, 1), 20000000012, 20000000001, 0.2, '2011-01-01');
Insert INTO Element_Def_Values (id, id_ed, id_obj, vlv, data)
    Values (GEN_ID(Gen_Element_Def_Values_ID, 1), 20000000013, 20000000001, 0.0, '2011-01-01');
    
Insert Into Elements (id, id_obj, amount, id_edizm, price, id_head)
    Values (GEN_ID(GEN_Elements_ID, 1), 20000000001, 10.0000, 20000000001, 1.0000, 20000000001);
Insert Into Elements (id, id_obj, amount, id_edizm, price, id_head)
    Values (GEN_ID(GEN_Elements_ID, 1), 20000000001,  8.0000, 20000000001, 2.0000, 20000000002);
Insert Into Elements (id, id_obj, amount, id_edizm, price, id_head)
    Values (GEN_ID(GEN_Elements_ID, 1), 20000000001,  3.0000, 20000000001, 3.0000, 20000000002);
Insert Into Elements (id, id_obj, amount, id_edizm, price, id_head)
    Values (GEN_ID(GEN_Elements_ID, 1), null, 10.0000, null, 1.0000, 20000000003);  

Insert INTO HEADERS (id, id_type, id_alloc_from, id_alloc_to, data)
    Values (GEN_ID(GEN_HEADERS_ID, 1), 20000000001, 20000000005, 20000000006, '2012-01-01');
Insert INTO HEADERS (id, id_type, id_alloc_from, id_alloc_to, data)
    Values (GEN_ID(GEN_HEADERS_ID, 1), 20000000002, 20000000006, 20000000007, '2012-01-01');
Insert INTO HEADERS (id, id_type, id_alloc_from, id_alloc_to, data)
    Values (GEN_ID(GEN_HEADERS_ID, 1),20000000003,  20000000006, 20000000005, '2012-02-01');
    
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '75-01', 1500, 9, 22, 1750, 35);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '75-03', 1500, 9, 22, 1750, 35);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '28-68', 1500, 13.4, 12, 1750, 35);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '47-89', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '56-11', 20000, 87, 40,    17000, 40);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '91-35',    20000,    87,    40,    17000, 40);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '89-13',    20000,    87,    40,    17000, 40);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '354-07', 13000, 29.9, 45, 12600, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '16-71', 10000, 29.9, 29, 7500,    35);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '81-71', 10000, 29.9, 29, 7500, 35);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '81-66', 10000, 29.9, 29, 7500, 35);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '22-68', 10000, 29.9, 29, 7500, 35);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '22-67', 10000, 29.9, 29, 7500, 35);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '22-66', 10000, 29.9, 29, 7500, 35);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '81-10', 5000, 34.5, 21, 3900, 40);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '81-70', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '81-69', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '81-68', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '65-58', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '65-55', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '65-37', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '22-73', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '22-61', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '18-27', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '18-26', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '18-24', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '06-93', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '06-88', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '06-85', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '06-69', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '06-68', 4000, 12.9, 20, 3350, 30);
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '47-92', 4000, 12.9, 20, 3350, 30);    
Insert INTO VEHICLE (id, num, LOAD_KG, BODY_OBJEM, RASXOD_LIT, weight, speed)
    Values (GEN_ID(GEN_VEHICLE_ID, 1), '06-70', 4000, 12.9, 20, 3350, 30);    
    


  suspend;
end^



SET TERM ; ^


SET TERM ^ ;

create procedure p_Prices_For_Snapshot (ID_OBJ  BIGINT)
returns (PRICE_FOR_TYPE1 FLOAT, PRICE_FOR_TYPE2 FLOAT, PRICE_FOR_TYPE3 FLOAT, PRICE_FOR_TYPE4 FLOAT,PRICE_FOR_TYPE5 FLOAT)
as
    DECLARE VARIABLE NPRICE VARCHAR(25);
    DECLARE VARIABLE DEFAULT_CURRENCY BIGINT;
begin
SELECT CAST(vlv AS BIGINT) FROM Properties WHERE name = 'default_currency' INTO :default_currency;
FOR SELECT name FROM Properties WHERE name LIKE 'PRICE_FOR_TYPE%'
    INTO :NPRICE DO
    BEGIN
     IF (:NPRICE = 'PRICE_FOR_TYPE1') THEN
        BEGIN
            SELECT p.price FROM Prices p
                WHERE p.id_type = (SELECT CAST(vlv AS BIGINT) AS p  FROM Properties
                                    WHERE name = 'PRICE_FOR_TYPE1')
                    and p.id_curr = :default_currency
                    AND
                    p.data = (SELECT MAX(data) FROM Prices
                                   WHERE id_obj = p.id_obj AND id_type = p.id_type and id_curr = p.id_curr)
            AND p.id_obj = :id_obj
            INTO :PRICE_FOR_TYPE1;
        END
     IF (:NPRICE = 'PRICE_FOR_TYPE2') THEN
        BEGIN
            SELECT p.price FROM Prices p
                WHERE p.id_type = (SELECT CAST(vlv AS BIGINT) AS p  FROM Properties
                                    WHERE name = 'PRICE_FOR_TYPE2')
                    and p.id_curr = :default_currency
                    AND
                    p.data = (SELECT MAX(data) FROM Prices
                                   WHERE id_obj = p.id_obj AND id_type = p.id_type and id_curr = p.id_curr)
            AND p.id_obj = :id_obj
            INTO :PRICE_FOR_TYPE2;
        END
     IF (:NPRICE = 'PRICE_FOR_TYPE3') THEN
        BEGIN
            SELECT p.price FROM Prices p
                WHERE p.id_type = (SELECT CAST(vlv AS BIGINT) AS p  FROM Properties
                                    WHERE name = 'PRICE_FOR_TYPE3')
                    and p.id_curr = :default_currency
                    AND
                    p.data = (SELECT MAX(data) FROM Prices
                                   WHERE id_obj = p.id_obj AND id_type = p.id_type and id_curr = p.id_curr)
            AND p.id_obj = :id_obj
            INTO :PRICE_FOR_TYPE3;
        END
     IF (:NPRICE = 'PRICE_FOR_TYPE4') THEN
        BEGIN
            SELECT p.price FROM Prices p
                WHERE p.id_type = (SELECT CAST(vlv AS BIGINT) AS p  FROM Properties
                                    WHERE name = 'PRICE_FOR_TYPE4') and p.id_curr = :default_currency
                    AND
                    p.data = (SELECT MAX(data) FROM Prices
                                   WHERE id_obj = p.id_obj AND id_type = p.id_type and id_curr = p.id_curr)
            AND p.id_obj = :id_obj
            INTO :PRICE_FOR_TYPE4;
        END
     IF (:NPRICE = 'PRICE_FOR_TYPE5') THEN
        BEGIN
            SELECT p.price FROM Prices p
                WHERE p.id_type = (SELECT CAST(vlv AS BIGINT) AS p  FROM Properties
                                    WHERE name = 'PRICE_FOR_TYPE5')
                    and p.id_curr = :default_currency
                    AND
                    p.data = (SELECT MAX(data) FROM Prices
                                   WHERE id_obj = p.id_obj AND id_type = p.id_type and id_curr = p.id_curr)
            AND p.id_obj = :id_obj
            INTO :PRICE_FOR_TYPE5;
        END
    end
  suspend;
end^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_out_party (
    id_e BIGINT NOT NULL = 1)
AS
DECLARE VARIABLE ID_OBJ BIGINT;
DECLARE VARIABLE ID_ALLOC_FROM BIGINT;
DECLARE VARIABLE ID_ALLOC_TO BIGINT;
DECLARE VARIABLE DATA date;
DECLARE VARIABLE ID_POS BIGINT;
DECLARE VARIABLE REMAINS numeric(18,5);
DECLARE VARIABLE PRICE numeric(18,5);
DECLARE VARIABLE FROM_PRICE numeric(18,5);
DECLARE VARIABLE AMOUNT numeric(18,5);
DECLARE VARIABLE TMP_AMOUNT numeric(18,5);
DECLARE VARIABLE prime_cost BIGINT;
BEGIN
DELETE FROM Element_Details WHERE id_e = :id_e;

SELECT vlv From Properties Where name = 'prime_cost'
      INTO :prime_cost;
SELECT e.id_obj, e.price, e.amount, h.data, h.id_alloc_from, h.id_alloc_to
     FROM Elements e INNER JOIN HEADERS h ON e.id_head = h.id WHERE e.id = :id_e
     INTO :id_obj, :price, :amount, :data, :id_alloc_from, :id_alloc_to;

tmp_amount = :amount;

for Select ED.ID_POS, Sum(ED.AMOUNT) as REMAINS From ELEMENT_DETAILS ED
    Where ED.ID_OBJ = :ID_OBJ and ED.DATA <= :DATA and
          ED.ID_ALLOC = :ID_ALLOC_FROM and
          ED.ID_POS <> -1
    group by ED.ID_POS
    INTO :id_pos, :remains DO
        BEGIN
            WHILE (:tmp_amount <> 0 AND :remains > 0) DO
            BEGIN
                IF (:prime_cost IS NULL) THEN
                    SELECT e.price FROM Elements e WHERE e.id = :id_pos
                    INTO :from_price;
                ELSE
                    Select Max(edv.vlv) as price From Element_Def ed Inner Join  Element_Def_Values edv
                            On ed.id = edv.id_ed
                        Where ed.id = cast(:prime_cost as BIGINT) and edv.id_obj = :ID_OBJ
                        and edv.data = (Select MAX(edv1.data) From Element_Def ed1 Inner Join  Element_Def_Values edv1
                                                On ed1.id = edv1.id_ed
                                                    Where ed1.id = ed.id and edv1.id_ed =edv.id_ed
                                                    and edv1.data <= :data)
                        Group by ed.id INTO :from_price;
                    IF (:remains >= :tmp_amount) THEN
                    BEGIN
                        INSERT INTO Element_Details (id, id_obj, data, id_alloc, price, amount, id_pos, id_e)
                            VALUES (GEN_ID(GEN_ELEMENT_DETAILS_ID,1), :id_obj, :data, :id_alloc_from, :from_price, :tmp_amount*-1, :id_pos, :id_e);
                        INSERT INTO Element_Details (id, id_obj, data, id_alloc, price, amount, id_pos, id_e)
                            VALUES (GEN_ID(GEN_ELEMENT_DETAILS_ID,1), :id_obj, :data, :id_alloc_to, :price,:tmp_amount, :id_e, :id_e);
                        tmp_amount=0;
                     END
                ELSE IF (:remains < :tmp_amount AND :remains > 0) THEN
                    BEGIN
                        INSERT INTO Element_Details (id, id_obj, data, id_alloc, price, amount, id_pos, id_e)
                            VALUES (GEN_ID(GEN_ELEMENT_DETAILS_ID,1), :id_obj, :data, :id_alloc_from, :from_price, :remains*-1, :id_pos, :id_e);
                        INSERT INTO Element_Details (id, id_obj, data, id_alloc, price, amount, id_pos, id_e)
                            VALUES (GEN_ID(GEN_ELEMENT_DETAILS_ID,1), :id_obj, :data, :id_alloc_to, :price, :remains, :id_e, :id_e);
                        tmp_amount = :tmp_amount - :remains;
                        remains = 0;
                    END
            END
        END


IF (:tmp_amount > 0) THEN
    BEGIN
                    INSERT INTO Element_Details (id, id_obj, data, id_alloc, price, amount, id_pos, id_e)
                        VALUES (GEN_ID(GEN_ELEMENT_DETAILS_ID,1), :id_obj, :data, :id_alloc_from, null, :tmp_amount*-1, -1, :id_e);
                    INSERT INTO Element_Details (id, id_obj, data, id_alloc, price, amount, id_pos, id_e)
                        VALUES (GEN_ID(GEN_ELEMENT_DETAILS_ID,1), :id_obj, :data, :id_alloc_to, :price, :tmp_amount, :id_e, :id_e);
    END                    
END^

SET TERM ; ^

/* Following GRANT statetements are generated automatically */

GRANT SELECT,INSERT,DELETE ON ELEMENT_DETAILS TO PROCEDURE P_OUT_PARTY;
GRANT SELECT ON PROPERTIES TO PROCEDURE P_OUT_PARTY;
GRANT SELECT ON ELEMENTS TO PROCEDURE P_OUT_PARTY;
GRANT SELECT ON HEADERS TO PROCEDURE P_OUT_PARTY;
GRANT SELECT ON ELEMENT_DEF TO PROCEDURE P_OUT_PARTY;
GRANT SELECT ON ELEMENT_DEF_VALUES TO PROCEDURE P_OUT_PARTY;

/* Existing privileges on this procedure */

GRANT EXECUTE ON PROCEDURE P_OUT_PARTY TO SYSDBA;


SET TERM ^ ;
CREATE OR ALTER PROCEDURE p_recreate_v_using
AS
DECLARE VARIABLE fld_value VARCHAR(50);
DECLARE VARIABLE string_sql VARCHAR(4000);
DECLARE VARIABLE string_sql_1 VARCHAR(4000);
DECLARE VARIABLE string_sql_2 VARCHAR(4000);
DECLARE cur_using CURSOR FOR (
    SELECT DISTINCT fld_name
    FROM dualrec);
BEGIN
  string_sql='ALTER VIEW v_Using AS ';
  string_sql_1='SELECT st.name, s.id, s.data, u.dt,u.kt,';
  string_sql_2=' as summa FROM v_Elements e Left Outer Join HEADERS h On e.id_head=h.id
                        Inner Join HeadTypes ht On h.id_type = ht.id 
                                Inner Join DUALREC u On u.id_head_type = ht.id Where u.fld_name=';
 open cur_using;
 FETCH cur_using INTO :fld_value;
 IF (:fld_value is not null) THEN
 BEGIN
 string_sql=:string_sql || :string_sql_1 || :fld_value || :string_sql_2 || ''''  || fld_value || '''';

    WHILE (1=1) DO
        BEGIN
            FETCH cur_using INTO :fld_value;
            IF (ROW_COUNT = 0) THEN LEAVE;
            string_sql=:string_sql || ' UNION ALL ' || :string_sql_1 || :fld_value || :string_sql_2 || '''' || :fld_value || '''';
        END
   EXECUTE STATEMENT :string_sql;
END
 close cur_using;
END^

SET TERM ; ^

/* Following GRANT statetements are generated automatically */

GRANT SELECT ON DUALREC TO PROCEDURE P_RECREATE_V_USING;

/* Existing privileges on this procedure */

GRANT EXECUTE ON PROCEDURE P_RECREATE_V_USING TO SYSDBA;

SET TERM ^ ;

CREATE OR ALTER PROCEDURE p_shortid (
    id BIGINT NOT NULL)
RETURNS (
    s_id CHAR(11))
AS
begin
  if (POSITION('000000000', SUBSTRING(cast(id as char(11)) FROM 1 FOR 10)) > 0) then
    s_id = '        ' || REPLACE(SUBSTRING(cast(id as char(11)) FROM 1 FOR 10), '000000000', '-')  || SUBSTRING(cast(id as char(11)) FROM 11);
        else if (POSITION('00000000', SUBSTRING(cast(id as char(11)) FROM 1 FOR 9)) > 0) then
          s_id = '       ' || REPLACE(SUBSTRING(cast(id as char(11)) FROM 1 FOR 9), '00000000', '-')  || SUBSTRING(cast(id as char(11)) FROM 10);
            else if (POSITION('0000000', SUBSTRING(cast(id as char(11)) FROM 1 FOR 8)) > 0) then
              s_id = '      ' || REPLACE(SUBSTRING(cast(id as char(11)) FROM 1 FOR 8), '0000000', '-')  || SUBSTRING(cast(id as char(11)) FROM 9);
                else if (POSITION('000000', SUBSTRING(cast(id as char(11)) FROM 1 FOR 7)) > 0) then
                  s_id = '     ' || REPLACE(SUBSTRING(cast(id as char(11)) FROM 1 FOR 7), '000000', '-')  || SUBSTRING(cast(id as char(11)) FROM 8);
                    else if (POSITION('00000', SUBSTRING(cast(id as char(11)) FROM 1 FOR 6)) > 0) then
                      s_id = '    ' || REPLACE(SUBSTRING(cast(id as char(11)) FROM 1 FOR 6), '00000', '-')  || SUBSTRING(cast(id as char(11)) FROM 7);
                        else if (POSITION('0000', SUBSTRING(cast(id as char(11)) FROM 1 FOR 5)) > 0) then
                          s_id = '   ' || REPLACE(SUBSTRING(cast(id as char(11)) FROM 1 FOR 5), '0000', '-')  || SUBSTRING(cast(id as char(11)) FROM 6);
                            else if (POSITION('000', SUBSTRING(cast(id as char(11)) FROM 1 FOR 4)) > 0) then
                              s_id = '  ' || REPLACE(SUBSTRING(cast(id as char(11)) FROM 1 FOR 4), '000', '-')  || SUBSTRING(cast(id as char(11)) FROM 5);
                                else if (POSITION('00', SUBSTRING(cast(id as char(11)) FROM 1 FOR 3)) > 0) then
                                  s_id = ' ' || REPLACE(SUBSTRING(cast(id as char(11)) FROM 1 FOR 3), '00', '-')  || SUBSTRING(cast(id as char(11)) FROM 4);
                                    else if (POSITION('0', SUBSTRING(cast(id as char(11)) FROM 1 FOR 2)) > 0) then
                                      s_id = '' || REPLACE(SUBSTRING(cast(id as char(11)) FROM 1 FOR 2), '0', '-')  || SUBSTRING(cast(id as char(11)) FROM 3);
    suspend;
end^

SET TERM ; ^

/******************* Triggers*******************/

/***********************************************/


SET TERM ^ ;

CREATE OR ALTER TRIGGER TG_DEF_ALLOCATION_AI FOR CUSTOMERS
ACTIVE AFTER INSERT POSITION 20
as
begin
     if ((inserting) and not exists (SELECT * FROM Allocation
                                      Where id_cus = new.id))
        then
            INSERT INTO Allocation (id, name, id_cus)
                VALUES (GEN_ID(GEN_Allocation_ID, 1), new.name || '/Основной склад', new.id);

end
^


SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER TRIGGER TG_DEF_DOGOVOR_AID FOR CUSTOMERS
ACTIVE AFTER INSERT POSITION 10
as
DECLARE VARIABLE DEF_CURRENCY BIGINT;
DECLARE VARIABLE DEF_PRICE BIGINT;
begin
SELECT CAST(vlv AS BIGINT) FROM Properties WHERE name = 'default_currency' INTO :def_currency;
SELECT CAST(vlv AS BIGINT) FROM Properties WHERE name = 'default_price' INTO :def_price;
     if ((inserting) and not exists (SELECT * FROM Contracts
                                      Where id_cus = new.id and vid = 1))
        then
            INSERT INTO Contracts (id, name, id_price, id_curr, id_cus, vid)
                VALUES (GEN_ID(GEN_CONTRACTS_ID, 1), 'Основной договор', :def_price, :def_currency, new.id, 1);

end
^

SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER TRIGGER TG_SNAPSHOT_PRICES_AID FOR PRICES
ACTIVE AFTER INSERT OR DELETE POSITION 10
AS
DECLARE VARIABLE ID_OBJ  BIGINT;
DECLARE VARIABLE PRICE_FOR_TYPE1 FLOAT;
DECLARE VARIABLE PRICE_FOR_TYPE2 FLOAT;
DECLARE VARIABLE PRICE_FOR_TYPE3 FLOAT;
DECLARE VARIABLE PRICE_FOR_TYPE4 FLOAT;
DECLARE VARIABLE PRICE_FOR_TYPE5 FLOAT;

BEGIN
         IF (INSERTING) THEN
                id_obj = NEW.id_obj;

         IF (DELETING) THEN
                id_obj = OLD.id_obj;

 Select PRICE_FOR_TYPE1, PRICE_FOR_TYPE2, PRICE_FOR_TYPE3, PRICE_FOR_TYPE4, PRICE_FOR_TYPE5
    From p_Prices_For_Snapshot(:id_obj)
                       INTO :PRICE_FOR_TYPE1, :PRICE_FOR_TYPE2, :PRICE_FOR_TYPE3, :PRICE_FOR_TYPE4, :PRICE_FOR_TYPE5;
 UPDATE SNAPSHOT_OBJECTS SET PRICE_FOR_TYPE1 = :PRICE_FOR_TYPE1, PRICE_FOR_TYPE2 = :PRICE_FOR_TYPE2,
                                       PRICE_FOR_TYPE3 = :PRICE_FOR_TYPE3, PRICE_FOR_TYPE4 = :PRICE_FOR_TYPE4,
                                        PRICE_FOR_TYPE5 = :PRICE_FOR_TYPE5
                                       WHERE id_obj = :id_obj;
END
^
SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER TRIGGER TG_SNAPSHOT_HEADERS_AID FOR HEADERS
ACTIVE AFTER INSERT OR DELETE POSITION 20
as
DECLARE VARIABLE  id_obj          BIGINT;
DECLARE VARIABLE  id_head         BIGINT;
begin
         IF (INSERTING) THEN
                id_head = new.id;

         IF (DELETING) THEN
                id_head = old.id;
id_obj=null;
    For Select e.id_obj From Elements e Where e.id_head = :id_head
        INTO :id_obj DO
        BEGIN
          UPDATE SNAPSHOT_OBJECTS Set amount =
            (Select amount From v_Remains Where id_obj = :id_obj)
                    Where id_obj = :id_obj;
        END
end
^
SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER TRIGGER TG_SNAPSHOT_OBJECTS_AID FOR OBJECTS
ACTIVE AFTER INSERT OR DELETE POSITION 10
as
/*$$IBEC$$ DECLARE VARIABLE PRICE_1 FLOAT;
DECLARE VARIABLE PRICE_2 FLOAT;
DECLARE VARIABLE PRICE_3 FLOAT;
DECLARE VARIABLE PRICE_4 FLOAT;
DECLARE VARIABLE PRICE_5 FLOAT; $$IBEC$$*/
begin
      if (inserting) then
            INSERT INTO SNAPSHOT_OBJECTS (id, id_obj)
                VALUES (GEN_ID(GEN_SNAPSHOT_OBJECTS_ID, 1), new.id);
         /*$$IBEC$$Select price_1, price_2, price_3, price_4, price_5 From p_Prices_For_Snapshot(new.id)
                               INTO :price_1, :price_2, :price_3, :price_4, :price_5;
            UPDATE SNAPSHOT_OBJECTS SET price_1 = :price_1, price_2 = :price_2,
                                               price_3 = :price_3, price_4 = :price_4, price_5 = :price_5
                                               WHERE id_obj = new.id;
          UPDATE SNAPSHOT_OBJECTS Set amount =
            (Select amount From v_Remains Where id_obj = new.id)
                    Where id_obj = new.id; $$IBEC$$*/

     if (deleting) then
            Delete From SNAPSHOT_OBJECTS Where id_obj =old.id;
end
^

SET TERM ; ^

SET TERM ^ ;



CREATE OR ALTER TRIGGER FILL_SID_CUSTOMERS_BI FOR CUSTOMERS
ACTIVE BEFORE INSERT POSITION 0
as
begin
    Select s_id From p_shortid(new.id) INTO new.s_id;
end
^


SET TERM ; ^


SET TERM ^ ;

CREATE OR ALTER TRIGGER FILL_SID_OBJECTS_BI FOR OBJECTS
ACTIVE BEFORE INSERT POSITION 0
as
begin
    Select s_id From p_shortid(new.id) INTO new.s_id;  
end
^
SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER TRIGGER FILL_SID_ALLOCATION_BI FOR ALLOCATION
ACTIVE BEFORE INSERT POSITION 0
as
begin
    Select s_id From p_shortid(new.id) INTO new.s_id;
end
^
SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER TRIGGER FILL_SID_TASK_TRANSP_BI FOR TASK_TRANSPORTATION
ACTIVE BEFORE INSERT POSITION 0
as
begin
    Select s_id From p_shortid(new.id) INTO new.s_id;
end
^
SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER TRIGGER FILL_SID_VEHICLE_BI FOR VEHICLE
ACTIVE BEFORE INSERT POSITION 0
as
begin
    Select s_id From p_shortid(new.id) INTO new.s_id;
end
^
SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER TRIGGER FILL_SID_HEADERS_BI FOR HEADERS
ACTIVE BEFORE INSERT POSITION 0
as
begin
    Select s_id From p_shortid(new.id) INTO new.s_id;
end
^
SET TERM ; ^


SET TERM ^ ;

CREATE OR ALTER TRIGGER TG_CHK_ISBASE_BIU0 FOR ELEMENT_DEF
ACTIVE AFTER INSERT OR UPDATE POSITION 0
AS
DECLARE VARIABLE cnt INTEGER;
DECLARE VARIABLE name VARCHAR(75);
begin
 Select Count(id) From Element_Def Where parent = new.parent and isbase = 1
 INTO :cnt;
  if (:cnt > 1)THEN
  begin
      Select First 1 name From Element_Def Where id = new.parent
      INTO :name;
      EXCEPTION EXCEPTION_DEF_ISBASE 'Для деформатора ' || :name || ' уже есть базовый!';
  END
end
^


SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER TRIGGER TG_RECREATE_V_USING_AIUD0 FOR DUALREC
INACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
  EXECUTE PROCEDURE p_recreate_v_using;
end
^
SET TERM ; ^


SET TERM ^ ;
CREATE OR ALTER TRIGGER ELEMENTS_DEFORMATION_AIUD_20 FOR ELEMENTS
INACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 20
AS
    DECLARE VARIABLE id_obj BIGINT;
    DECLARE VARIABLE id_edv BIGINT;
    DECLARE VARIABLE data date;

BEGIN
if (inserting or updating)
then
begin
    select e.id_obj, h.data from elements e Inner join HEADERS h
        On e.id_head = h.id Where e.id = new.id INTO :id_obj, :data;
FOR Select edv.id From Element_Def ed Inner Join  Element_Def_Values edv
        On ed.id = edv.id_ed
    Where ed.isbase = 1 and edv.id_obj = :id_obj
    and edv.data = (Select MAX(edv1.data) From Element_Def ed1 Inner Join  Element_Def_Values edv1
                            On ed1.id = edv1.id_ed
                                Where ed1.isbase = 1 and edv1.id_ed =edv.id_ed 
                                and edv1.data <= :data)
    UNION
    Select edv.id From Element_Def ed Inner Join  Element_Def_Values edv
        On ed.id = edv.id_ed
    Where ed.isbase = 1 and edv.id_obj is null and NOT EXISTS
        (Select * From Element_Def ed3 Inner Join  Element_Def_Values edv3
        On ed3.id = edv3.id_ed
    Where ed3.isbase = 1 and edv3.id_obj = :id_obj and edv3.id_ed = edv.id_ed
    and edv3.data = (Select MAX(edv1.data) From Element_Def ed1 Inner Join  Element_Def_Values edv1
                            On ed1.id = edv1.id_ed
                                Where ed1.isbase = 1 and edv1.id_ed =edv3.id_ed 
                                and edv1.data <= :data))
    and edv.data = (Select MAX(edv1.data) From Element_Def ed1 Inner Join  Element_Def_Values edv1
                            On ed1.id = edv1.id_ed
                                Where ed1.isbase = 1 and edv1.id_ed =edv.id_ed 
                                and edv1.data <= :data)
                                INTO :id_edv do
        begin
            INSERT INTO Element_Def2_Elements (id, id_e, id_edv)
                VALUES (GEN_ID(GEN_ELEMENT_DEF2_Elements_ID, 1), new.id, :id_edv);
        end
end
    if (deleting)
    then Delete From Element_Def2_Elements Where id_e =old.id;
end
^
SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER TRIGGER TG_HEADERS_OUT_PARTY_AI FOR HEADERS
INACTIVE AFTER INSERT POSITION 10
as
DECLARE VARIABLE  id_e            BIGINT;
DECLARE VARIABLE  id_obj          BIGINT;
begin
id_obj=null;
    For Select e.id From Elements e Where e.id_head = new.id
        INTO :id_e DO
        BEGIN
          execute procedure p_out_party (:id_e);
        END
    For Select e.id_obj From Elements e Where e.id_head = new.id
            Group by e.id_obj
        INTO :id_obj DO
        BEGIN
          For Select e.id From Headers h Join Elements e On h.id = e.id_head
                Where h.id <> new.id and e.id_obj = :id_obj
                        and h.data > new.data
                                INTO :id_e DO
                                BEGIN
                                  execute procedure p_out_party (:id_e);
                                END
        END
end
^
SET TERM ; ^

SET TERM ^ ;

CREATE OR ALTER TRIGGER TG_HEADERS_OUT_PARTY_AD FOR HEADERS
INACTIVE AFTER DELETE POSITION 9
as
DECLARE VARIABLE  id_e            BIGINT;
DECLARE VARIABLE  id_obj          BIGINT;
begin
id_obj=null;
    For Select e.id From Elements e Where e.id_head = old.id
        INTO :id_e DO
        BEGIN
            DELETE From Element_Details Where id_e = :id_e;
        END
    /*For Select e.id_obj From Elements e Where e.id_head = old.id
            Group by e.id_obj
        INTO :id_obj DO
        BEGIN
          For Select e.id From Elements e Inner Join Headers h On e.id_head = h.id
                Where e.id_head <> old.id and e.id_obj = :id_obj
                        and h.data >= old.data
                                INTO :id_e DO
                                BEGIN
                                  execute procedure p_out_party (:id_e);
                                END
        END*/
end
^
SET TERM ; ^

SET TERM ^ ;
CREATE OR ALTER TRIGGER TG_OUT_PARTY_ELEMENTS_AIUD0 FOR ELEMENTS
INACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 10
AS

DECLARE VARIABLE  id_e            BIGINT;
DECLARE VARIABLE  id_obj          BIGINT;
--DECLARE VARIABLE  depth_out_party INTEGER;
DECLARE VARIABLE  data               DATE;
BEGIN
id_obj=null;
--Select cast(vlv as INTEGER) From Properties Where name = 'depth_out_party'
--    INTO : depth_out_party;
IF (old.id_obj IS NOT NULL) THEN
BEGIN
id_obj=old.id_obj;
 SELECT h.data From Headers h Where h.id = old.id_head INTO :data;
    --execute procedure p_out_party(:id);
    DELETE FROM Element_Details WHERE id_e = old.id;
    FOR Select id_e From p_move_obj(:id_obj, :data)
        INTO :id_e DO
        BEGIN
            execute procedure p_out_party (:id_e);
        END

END



    IF (new.id_obj IS NOT NULL) THEN
    BEGIN
     id_obj=new.id_obj;
     SELECT h.data From Headers h Where h.id = new.id_head INTO :data;
        execute procedure p_out_party (new.id);
        FOR Select id_e From p_move_obj(:id_obj, :data)
        INTO :id_e DO
        BEGIN
          execute procedure p_out_party (:id_e);
        END
    END

END
^


SET TERM ; ^


/**************************************************************************************/

EXECUTE PROCEDURE P_FILL_BASE;
EXECUTE PROCEDURE P_FILL_DICTIONARY;
SET STATISTICS INDEX ELEMENT_DETAILS_OBJ_POS_IDX;
COMMIT WORK;